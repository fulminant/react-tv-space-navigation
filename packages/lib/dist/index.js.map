{"version":3,"file":"index.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA,CAAC,oCAAoC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA,6CAA6C;AAC7C;AACA,CAAC;AACD;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,QAAQ,kCAAkC,eAAe,0BAA0B,mBAAmB,eAAe,iDAAiD,oBAAoB,eAAe,6BAA6B,MAAM,4CAA4C,QAAQ;;AAEjT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS,gEAAgE;AACxF,oFAAoF,iCAAiC;AACrH;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,4CAA4C,sBAAsB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,4BAA4B;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oCAAoC;AAC1E;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,0BAA0B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4BAA4B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,qEAAqE;AACrE;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iGAAiG;AACjG;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEyC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9zC1C,MAAAA,MAAA,GAAAC,mBAAA;AASA,MAAqB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CA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjKA,WAAW,mBAAO,CAAC,IAAS;;AAE5B;AACA;;AAEA;;;;;;;;ACLA,aAAa,mBAAO,CAAC,GAAW;AAChC,gBAAgB,mBAAO,CAAC,IAAc;AACtC,qBAAqB,mBAAO,CAAC,IAAmB;;AAEhD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3BA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC9BA,sBAAsB,mBAAO,CAAC,IAAoB;;AAElD;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClBA,gBAAgB,mBAAO,CAAC,IAAc;AACtC,qBAAqB,mBAAO,CAAC,IAAmB;AAChD,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7BA;AACA,wBAAwB,qBAAM,gBAAgB,qBAAM,IAAI,qBAAM,sBAAsB,qBAAM;;AAE1F;;;;;;;;ACHA,aAAa,mBAAO,CAAC,GAAW;;AAEhC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7CA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxBA,SAAS,mBAAO,CAAC,IAAM;AACvB,kBAAkB,mBAAO,CAAC,IAAe;AACzC,cAAc,mBAAO,CAAC,IAAY;AAClC,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7BA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;ACrBA,iBAAiB,mBAAO,CAAC,IAAe;;AAExC;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACRA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AClBA,gBAAgB,mBAAO,CAAC,IAAc;AACtC,qBAAqB,mBAAO,CAAC,IAAmB;AAChD,gBAAgB,mBAAO,CAAC,IAAa;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpCA,iBAAiB,mBAAO,CAAC,IAAc;AACvC,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChCA,iBAAiB,mBAAO,CAAC,IAAe;AACxC,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC5BA,iBAAiB,mBAAO,CAAC,IAAe;AACxC,mBAAmB,mBAAO,CAAC,IAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC5BA,kBAAkB,mBAAO,CAAC,IAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7CA,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzCA,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACnCA,eAAe,mBAAO,CAAC,IAAa;AACpC,eAAe,mBAAO,CAAC,IAAY;AACnC,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa,MAAM,mBAAO,CAAC,IAAO,6KAA6K;AAC/M,kBAAkB,UAAU,eAAe,qBAAqB,6BAA6B,0BAA0B,0DAA0D,4EAA4E,OAAO,wDAAwD,gBAAgB,GAAG,WAAW,GAAG,YAAY;;;;;;;;;ACV5V;;AAEb,IAAI,IAAqC;AACzC,EAAE,0CAAqE;AACvE,EAAE,KAAK,EAEN;;;;;;;;;ACND;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACNA,MAAA6U,wBAAA,GAAAlc,mBAAA;AACA,IAAAD,MAAA,GAAAC,mBAAA;AAAS0E,8CAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAAhX,MAAA,CAAA6c,UAAU;EAAA;AAAA;AACnB,IAAAha,MAAA,GAAA5C,mBAAA;AAAS0E,yDAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAAnU,MAAA,CAAA6B,qBAAqB;EAAA;AAAA;AAC9B,IAAAoY,MAAA,GAAA7c,mBAAA;AAAS0E,yDAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAA8F,MAAA,CAAAtU,qBAAqB;EAAA;AAAA;AAC9B,IAAAuU,YAAA,GAAA9c,mBAAA;AAAS0E,+DAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAA+F,YAAA,CAAApS,2BAA2B;EAAA;AAAA;AACpC,IAAAqS,MAAA,GAAA/c,mBAAA;AAAS0E,yDAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAAgG,MAAA,CAAAjQ,qBAAqB;EAAA;AAAA;AAC9B,IAAAtH,qBAAA,GAAAxF,mBAAA;AAAS0E,gDAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAAvR,qBAAA,CAAAmV,YAAY;EAAA;AAAA;AACrB,IAAAtN,kCAAA,GAAArN,mBAAA;AAAS0E,oEAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAA1J,kCAAA,CAAAwC,gCAAgC;EAAA;AAAA;AACzC,IAAAmN,kCAAA,GAAAhd,mBAAA;AAAS0E,oEAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAAiG,kCAAA,CAAAtO,gCAAgC;EAAA;AAAA;AACzC,IAAA1L,gDAAA,GAAAhD,mBAAA;AAAS0E,kFAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAA/T,gDAAA,CAAAkC,8CAA8C;EAAA;AAAA;AACvD,IAAAmD,8BAAA,GAAArI,mBAAA;AAAS0E,4DAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAA1O,8BAAA,CAAAwT,wBAAwB;EAAA;AAAA;AAGjC,IAAAoB,eAAA,GAAAjd,mBAAA;AAAS0E,kEAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAAkG,eAAA,CAAAha,8BAA8B;EAAA;AAAA;AACvC,IAAAF,eAAA,GAAA/C,mBAAA;AAAS0E,uEAAA;EAAAiY,UAAA;EAAA5F,GAAA,WAAAA,CAAA;IAAA,OAAAhU,eAAA,CAAAgY,mCAAmC;EAAA;AAAA;AAE/BrY,yBAAiB,GAAG;EAC/B2X,sBAAsB,EAAtB6B,wBAAA,CAAA7B;CACD,C","sources":["webpack://ReactSpatialNavigation/webpack/universalModuleDefinition","webpack://ReactSpatialNavigation/../../node_modules/@bam.tech/lrud/dist/esm/index.js","webpack://ReactSpatialNavigation/./src/spatial-navigation/SpatialNavigator.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/FocusableView.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/Node.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/Root.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/ScrollView.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/View.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedGrid/SpatialNavigationVirtualizedGrid.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedGrid/helpers/convertToGrid.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/SpatialNavigationVirtualizedList.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/SpatialNavigationVirtualizedListWithScroll.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/SpatialNavigationVirtualizedListWithVirtualNodes.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/VirtualizedList.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/VirtualizedListWithSize.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/helpers/addIndex.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/helpers/computeTranslation.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/helpers/createScrollOffsetArray.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/helpers/getLastItemIndex.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/helpers/getRange.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/helpers/getSizeInPxFromOneItemToAnother.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/helpers/updateVirtualNodeRegistration.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/hooks/useCachedValues.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/components/virtualizedList/hooks/useVirtualizedListAnimation.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/configureRemoteControl.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/context/DefaultFocusContext.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/context/DeviceContext.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/context/LockSpatialNavigationContext.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/context/ParentIdContext.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/context/ParentScrollContext.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/context/SpatialNavigatorContext.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/helpers/TypedForwardRef.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/helpers/TypedMemo.tsx","webpack://ReactSpatialNavigation/./src/spatial-navigation/helpers/scrollToNewlyfocusedElement.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/hooks/useCreateSpatialNavigator.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/hooks/useRemoteControl.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/hooks/useSpatialNavigatorFocusableAccessibilityProps.ts","webpack://ReactSpatialNavigation/./src/spatial-navigation/hooks/useUniqueId.ts","webpack://ReactSpatialNavigation/../../node_modules/lodash.uniqueid/index.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_Symbol.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_baseGetTag.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_baseRange.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_baseSlice.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_baseTrim.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_createRange.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_freeGlobal.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_getRawTag.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_isIndex.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_isIterateeCall.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_objectToString.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_root.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/_trimmedEndIndex.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/chunk.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/eq.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/isArrayLike.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/isFunction.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/isLength.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/isObject.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/isObjectLike.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/isSymbol.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/range.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/toFinite.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/toInteger.js","webpack://ReactSpatialNavigation/../../node_modules/lodash/toNumber.js","webpack://ReactSpatialNavigation/../../node_modules/react/cjs/react-jsx-runtime.production.min.js","webpack://ReactSpatialNavigation/../../node_modules/react/jsx-runtime.js","webpack://ReactSpatialNavigation/external umd \"react\"","webpack://ReactSpatialNavigation/external umd \"react-native\"","webpack://ReactSpatialNavigation/webpack/bootstrap","webpack://ReactSpatialNavigation/webpack/runtime/define property getters","webpack://ReactSpatialNavigation/webpack/runtime/global","webpack://ReactSpatialNavigation/webpack/runtime/hasOwnProperty shorthand","webpack://ReactSpatialNavigation/webpack/runtime/make namespace object","webpack://ReactSpatialNavigation/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"react-native\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ReactSpatialNavigation\", [\"react\", \"react-native\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactSpatialNavigation\"] = factory(require(\"react\"), require(\"react-native\"));\n\telse\n\t\troot[\"ReactSpatialNavigation\"] = factory(root[\"react\"], root[\"react-native\"]);\n})(this, (__WEBPACK_EXTERNAL_MODULE__8156__, __WEBPACK_EXTERNAL_MODULE__9925__) => {\nreturn ","/* eslint no-unused-vars: \"off\", @typescript-eslint/no-explicit-any: \"off\", no-use-before-define: \"off\" */\r\nvar Directions;\r\n(function (Directions) {\r\n    Directions[\"LEFT\"] = \"left\";\r\n    Directions[\"RIGHT\"] = \"right\";\r\n    Directions[\"UP\"] = \"up\";\r\n    Directions[\"DOWN\"] = \"down\";\r\n    Directions[\"ENTER\"] = \"enter\";\r\n    Directions[\"UNSPECIFIED\"] = \"*\";\r\n})(Directions || (Directions = {}));\r\nvar Orientations;\r\n(function (Orientations) {\r\n    Orientations[\"VERTICAL\"] = \"vertical\";\r\n    Orientations[\"HORIZONTAL\"] = \"horizontal\";\r\n})(Orientations || (Orientations = {}));\n\nvar KeyCodes = {\r\n    4: Directions.LEFT,\r\n    21: Directions.LEFT,\r\n    37: Directions.LEFT,\r\n    214: Directions.LEFT,\r\n    205: Directions.LEFT,\r\n    218: Directions.LEFT,\r\n    5: Directions.RIGHT,\r\n    22: Directions.RIGHT,\r\n    39: Directions.RIGHT,\r\n    213: Directions.RIGHT,\r\n    206: Directions.RIGHT,\r\n    217: Directions.RIGHT,\r\n    29460: Directions.UP,\r\n    19: Directions.UP,\r\n    38: Directions.UP,\r\n    211: Directions.UP,\r\n    203: Directions.UP,\r\n    215: Directions.UP,\r\n    29461: Directions.DOWN,\r\n    20: Directions.DOWN,\r\n    40: Directions.DOWN,\r\n    212: Directions.DOWN,\r\n    204: Directions.DOWN,\r\n    216: Directions.DOWN,\r\n    29443: Directions.ENTER,\r\n    13: Directions.ENTER,\r\n    67: Directions.ENTER,\r\n    32: Directions.ENTER,\r\n    23: Directions.ENTER,\r\n    195: Directions.ENTER\r\n};\n\n/**\r\n * Given an array of values and a goal, return the value from values which is closest to the goal.\r\n *\r\n * @param {number[]} values\r\n * @param {number} goal\r\n */\r\nvar closestIndex = function (values, goal) { return values.reduce(function (prev, curr) {\r\n    return (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev);\r\n}); };\r\n/**\r\n * Checks if a given node is focusable.\r\n *\r\n * @param {object} node - node to check against focusability\r\n */\r\nvar isNodeFocusable = function (node) {\r\n    if (!node) {\r\n        return false;\r\n    }\r\n    return node.isFocusable != null ? node.isFocusable : !!node.selectAction;\r\n};\r\n/**\r\n * Given a keyCode, lookup and return the direction from the keycodes mapping file.\r\n *\r\n * @param {number} keyCode - key code for which corresponding direction is searched\r\n */\r\nvar getDirectionForKeyCode = function (keyCode) {\r\n    return KeyCodes[keyCode];\r\n};\r\n/**\r\n * Given an orientation and a direction, do they match?\r\n *\r\n * I.e an orientation `horizontal` and direction `left` or `right` is considered matching.\r\n *\r\n * Direction CAN be passed as `*` (wildcard). this will always return true.\r\n *\r\n * @param {string} orientation - orientation to match with the direction\r\n * @param {string} direction - direction to match with the orientation\r\n */\r\nvar isDirectionAndOrientationMatching = function (orientation, direction) {\r\n    if (!orientation || !direction) {\r\n        return false;\r\n    }\r\n    var validOrientation = toValidOrientation(orientation);\r\n    var validDirection = toValidDirection(direction);\r\n    return ((validDirection === Directions.UNSPECIFIED) ||\r\n        (validOrientation === Orientations.VERTICAL && (validDirection === Directions.UP || validDirection === Directions.DOWN)) ||\r\n        (validOrientation === Orientations.HORIZONTAL && (validDirection === Directions.LEFT || validDirection === Directions.RIGHT)));\r\n};\r\n/**\r\n * Returns a child from the given node whose indexRange encompasses the given index.\r\n *\r\n * @param {object} node - node, which children index ranges will be examined\r\n * @param {number} index - examined index value\r\n */\r\nvar findChildWithMatchingIndexRange = function (node, index) {\r\n    if (!node || !node.children) {\r\n        return undefined;\r\n    }\r\n    for (var i = 0; i < node.children.length; i++) {\r\n        var child = node.children[i];\r\n        if (child.indexRange && (child.indexRange[0] <= index && child.indexRange[1] >= index)) {\r\n            return child;\r\n        }\r\n    }\r\n    return undefined;\r\n};\r\n/**\r\n * Returns a child from the given node whose index is numerically closest to the given index.\r\n *\r\n * If an indexRange is provided, first check if the node's activeChild is inside\r\n * the indexRange. If it is, return the activeChild node instead\r\n *\r\n * @param {object} node\r\n * @param {number} index\r\n * @param {number[]} indexRange\r\n */\r\nvar findChildWithClosestIndex = function (node, index, indexRange) {\r\n    if (!node || !node.children) {\r\n        return undefined;\r\n    }\r\n    // if we have an indexRange, and the nodes active child is inside that index range,\r\n    // just return the active child\r\n    if (indexRange && node.activeChild &&\r\n        node.activeChild.index >= indexRange[0] && node.activeChild.index <= indexRange[1] &&\r\n        isNodeFocusable(node.activeChild)) {\r\n        return node.activeChild;\r\n    }\r\n    var indices = [];\r\n    for (var i = 0; i < node.children.length; i++) {\r\n        if (isNodeFocusable(node.children[i]) || node.children[i].children) {\r\n            indices.push(i);\r\n        }\r\n    }\r\n    if (indices.length <= 0) {\r\n        return undefined;\r\n    }\r\n    return node.children[closestIndex(indices, index)];\r\n};\r\n/**\r\n * Inserts given child to the parent's children, keeping indices coherent and compact.\r\n *\r\n * @param parent - node to which new child is about to be added\r\n * @param newChild - node to be added to the parent\r\n */\r\nvar insertChildNode = function (parent, newChild) {\r\n    if (!parent || !newChild) {\r\n        return;\r\n    }\r\n    if (!parent.children) {\r\n        parent.children = [];\r\n    }\r\n    newChild.parent = parent;\r\n    if (typeof newChild.index !== 'number' || newChild.index > parent.children.length) {\r\n        newChild.index = parent.children.length;\r\n        parent.children.push(newChild);\r\n    }\r\n    else {\r\n        // Inserting new child, from now on all further children needs to have index value increased by one\r\n        parent.children.splice(newChild.index, 0, newChild);\r\n        for (var i = newChild.index + 1; i < parent.children.length; i++) {\r\n            parent.children[i].index = i;\r\n        }\r\n    }\r\n};\r\n/**\r\n * Removes given child from the parent's children, keeping indices coherent and compact.\r\n *\r\n * @param parent - node from which children given child is about to be removed\r\n * @param child - node to be removed from parent's children\r\n */\r\nvar removeChildNode = function (parent, child) {\r\n    if (!child || !parent || !parent.children) {\r\n        return;\r\n    }\r\n    var removedChildIndex = -1;\r\n    for (var i = 0; i < parent.children.length; i++) {\r\n        if (parent.children[i] === child) {\r\n            removedChildIndex = i;\r\n        }\r\n        else if (removedChildIndex !== -1) {\r\n            parent.children[i].index = i - 1;\r\n        }\r\n    }\r\n    if (removedChildIndex !== -1) {\r\n        if (parent.children.length === 1) {\r\n            parent.children = undefined;\r\n        }\r\n        else {\r\n            parent.children.splice(removedChildIndex, 1);\r\n        }\r\n    }\r\n};\r\n/**\r\n * Returns valid orientation parameter.\r\n *\r\n * TypeScript defines type appropriately, but in JavaScript anything can be passed. Method doesn't imply that user\r\n * might be malicious, it just tries to unify provided string values, by making them a valid Orientation type.\r\n *\r\n * @param orientation - orientation to correct\r\n */\r\nvar toValidOrientation = function (orientation) {\r\n    if (!orientation) {\r\n        return undefined;\r\n    }\r\n    for (var _i = 0, _a = Object.keys(Orientations); _i < _a.length; _i++) {\r\n        var orientationKey = _a[_i];\r\n        if (Orientations[orientationKey] === orientation.toLowerCase()) {\r\n            return Orientations[orientationKey];\r\n        }\r\n    }\r\n    return undefined;\r\n};\r\n/**\r\n * Returns valid direction parameter.\r\n *\r\n * TypeScript defines type appropriately, but in JavaScript anything can be passed. Method doesn't imply that user\r\n * might be malicious, it just tries to unify provided string values, by making them a valid Orientation type.\r\n *\r\n * @param direction - direction to correct\r\n */\r\nvar toValidDirection = function (direction) {\r\n    if (!direction) {\r\n        return undefined;\r\n    }\r\n    for (var _i = 0, _a = Object.keys(Directions); _i < _a.length; _i++) {\r\n        var directionKey = _a[_i];\r\n        if (Directions[directionKey] === direction.toLowerCase()) {\r\n            return Directions[directionKey];\r\n        }\r\n    }\r\n    return undefined;\r\n};\r\n/**\r\n * Creates node object from given node parameters.\r\n *\r\n * Node creation method is optimized for JavaScript engine.\r\n * Objects created in \"the same way\" allows JavaScript engine reusing existing HiddenClass transition chain.\r\n * Moreover most used properties are defined \"at the beginning\" making access to them a bit faster.\r\n *\r\n * @param {string} nodeId - id of the node\r\n * @param {object} [nodeConfig] - node parameters\r\n */\r\nvar prepareNode = function (nodeId, nodeConfig) {\r\n    if (nodeConfig === void 0) { nodeConfig = {}; }\r\n    if (!nodeId) {\r\n        throw Error('Node ID has to be defined');\r\n    }\r\n    return {\r\n        id: nodeId,\r\n        parent: undefined,\r\n        children: undefined,\r\n        activeChild: undefined,\r\n        overrides: undefined,\r\n        overrideSources: undefined,\r\n        index: (typeof nodeConfig.index === 'number') ? nodeConfig.index : undefined,\r\n        orientation: nodeConfig.orientation,\r\n        indexRange: nodeConfig.indexRange,\r\n        selectAction: nodeConfig.selectAction,\r\n        isFocusable: nodeConfig.isFocusable,\r\n        isWrapping: nodeConfig.isWrapping,\r\n        isStopPropagate: nodeConfig.isStopPropagate,\r\n        isIndexAlign: nodeConfig.isIndexAlign,\r\n        useMeForIndexAlign: nodeConfig.useMeForIndexAlign,\r\n        onLeave: nodeConfig.onLeave,\r\n        onEnter: nodeConfig.onEnter,\r\n        shouldCancelLeave: nodeConfig.shouldCancelLeave,\r\n        onLeaveCancelled: nodeConfig.onLeaveCancelled,\r\n        shouldCancelEnter: nodeConfig.shouldCancelEnter,\r\n        onEnterCancelled: nodeConfig.onEnterCancelled,\r\n        onSelect: nodeConfig.onSelect,\r\n        onInactive: nodeConfig.onInactive,\r\n        onActive: nodeConfig.onActive,\r\n        onActiveChildChange: nodeConfig.onActiveChildChange,\r\n        onBlur: nodeConfig.onBlur,\r\n        onFocus: nodeConfig.onFocus,\r\n        onMove: nodeConfig.onMove\r\n    };\r\n};\r\n/**\r\n * Traverses through node subtree (including the node) with iterative preorder deep first search tree traversal algorithm.\r\n *\r\n * DFS is implemented without recursion to avoid putting methods to the stack. This allows traversing deep trees without\r\n * the need of allocating memory for recursive method calls.\r\n *\r\n * For some processes, when node meeting some condition is searched, there's no need to traverse through whole tree.\r\n * To address that, given nodeProcessor may return boolean value. when true is returned, than traversal algorithm\r\n * is interrupted immediately.\r\n *\r\n * E.g. Given tree:\r\n *        root\r\n *        / \\\r\n *       A   B\r\n *      /     \\\r\n *     AA      BA\r\n *    /  \\\r\n *  AAA  AAB\r\n *\r\n *  Traversal path: root -> A -> AA -> AAA -> AAB -> B -> BA\r\n *\r\n * @param {object} startNode - node that is the root of traversed subtree\r\n * @param {function} nodeProcessor - callback executed for traversed node, if true is returned then subtree traversal is interrupted\r\n */\r\nvar traverseNodeSubtree = function (startNode, nodeProcessor) {\r\n    var stack = [startNode];\r\n    var dummyThis = Object.create(null);\r\n    var traversedNode;\r\n    while (stack.length > 0) {\r\n        traversedNode = stack.pop();\r\n        if (nodeProcessor.call(dummyThis, traversedNode)) {\r\n            return;\r\n        }\r\n        if (traversedNode.children) {\r\n            for (var i = traversedNode.children.length - 1; i >= 0; i--) {\r\n                stack.push(traversedNode.children[i]);\r\n            }\r\n        }\r\n    }\r\n};\n\nfunction mitt(n){return {all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e]);},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]));},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e);}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e);});}}}\n\nvar Lrud = /** @class */ (function () {\r\n    function Lrud() {\r\n        this.nodes = {};\r\n        this.rootNode = undefined;\r\n        this.currentFocusNode = undefined;\r\n        this.isIndexAlignMode = false;\r\n        this.emitter = mitt();\r\n    }\r\n    /**\r\n     * Registers a callback for an LRUD event.\r\n     *\r\n     * @param {string} eventName - event to subscribe to\r\n     * @param {function} callback - function to call on event\r\n     */\r\n    Lrud.prototype.on = function (eventName, callback) {\r\n        this.emitter.on(eventName, callback);\r\n    };\r\n    /**\r\n     * Unregisters a callback for an LRUD event.\r\n     *\r\n     * @param {string} eventName - event to unsubscribe from\r\n     * @param {function} callback - function that was added using .on()\r\n     */\r\n    Lrud.prototype.off = function (eventName, callback) {\r\n        this.emitter.off(eventName, callback);\r\n    };\r\n    /**\r\n     * Returns the root node.\r\n     */\r\n    Lrud.prototype.getRootNode = function () {\r\n        if (!this.rootNode) {\r\n            throw new Error('no root node');\r\n        }\r\n        return this.rootNode;\r\n    };\r\n    /**\r\n     * Returns the current focused node.\r\n     */\r\n    Lrud.prototype.getCurrentFocusNode = function () {\r\n        return this.currentFocusNode;\r\n    };\r\n    /**\r\n     * Registers a new node into the LRUD tree.\r\n     *\r\n     * @param {string} nodeId - id of the node to register\r\n     * @param {object} [nodeConfig] - registered node parameters\r\n     * @param {string} [nodeConfig.parent] - parent node id, if null, default root node is used\r\n     * @param {number} [nodeConfig.index] - if null, index is 1 more than the index of the last sibling. if no previous siblings, index is 1\r\n     * @param {number[]} [nodeConfig.indexRange] - defaults to null. acts as a colspan, value [0] is lower bound, value [1] is upper bound\r\n     * @param {object} [nodeConfig.selectAction] - if a node has a selectAction, it is focusable\r\n     * @param {boolean} [nodeConfig.isFocusable] - if a node is explicitly set as isFocusable, it is focusable\r\n     * @param {boolean} [nodeConfig.isWrapping] - if true, when asking for the next child at the end or start of the node, the will \"wrap around\" and return the first/last (when asking for the last/first)\r\n     * @param {string} [nodeConfig.orientation] - can be \"vertical\" or \"horizontal\". is used in conjunction when handling direction of key press, to determine which child is \"next\"\r\n     * @param {boolean} [nodeConfig.isIndexAlign]  -if a node is index aligned, its descendents should jump to nodes based on index instead of activeChild\r\n     * @param {function} [nodeConfig.onLeave] - if a node has an `onLeave` function, it will be run when a move event leaves this node\r\n     * @param {function} [nodeConfig.onEnter] - if a node has an `onEnter` function, it will be run when a move event enters this node\r\n     */\r\n    Lrud.prototype.registerNode = function (nodeId, nodeConfig) {\r\n        var _a;\r\n        if (nodeConfig === void 0) { nodeConfig = {}; }\r\n        if (this.getNode(nodeId)) {\r\n            throw Error(\"Node with an ID of \" + nodeId + \" has already been registered\");\r\n        }\r\n        // It is not allowed to register node directly with children, for such purposes registerTree should be used\r\n        var node = prepareNode(nodeId, nodeConfig);\r\n        // if this is the very first node, set it as root and return...\r\n        if (!this.rootNode) {\r\n            this.rootNode = node;\r\n            this.nodes = (_a = {}, _a[nodeId] = node, _a);\r\n            return this;\r\n        }\r\n        // if this node config has no parent, assume its parent is root\r\n        var parentNode = nodeConfig.parent ? this.getNode(nodeConfig.parent) : this.rootNode;\r\n        // to keep tree coherent, nodes that are about to be added to not existing parent are ignored\r\n        if (!parentNode) {\r\n            return this;\r\n        }\r\n        // add the node into the tree\r\n        this.nodes[nodeId] = node;\r\n        insertChildNode(parentNode, node);\r\n        return this;\r\n    };\r\n    /**\r\n     * Allows to change node's parent by moving it's whole sub-tree.\r\n     *\r\n     * @param {string|object} node - node or id of the node that is about to change parent\r\n     * @param {string|object} newParentNode - node or id of the node that became a new parent for nodeId\r\n     * @param {object} [options]\r\n     * @param {number} [options.index] - index at which nodeId should be inserted as a child of newParentNodeId\r\n     * @param {boolean} [options.maintainIndex] - applies only if index is not defined; if true, node will be inserted at\r\n     *                                           it's current position if possible; otherwise node will be appended; default: false\r\n     */\r\n    Lrud.prototype.moveNode = function (node, newParentNode, options) {\r\n        if (options === void 0) { options = { maintainIndex: false }; }\r\n        node = typeof node === 'string' ? this.getNode(node) : node;\r\n        newParentNode = typeof newParentNode === 'string' ? this.getNode(newParentNode) : newParentNode;\r\n        if (!node || !newParentNode) {\r\n            return;\r\n        }\r\n        // It's not possible to move root node\r\n        if (node === this.rootNode) {\r\n            return;\r\n        }\r\n        // There's no need to change the parent\r\n        if (node.parent === newParentNode) {\r\n            return;\r\n        }\r\n        var oldParentNode = node.parent;\r\n        // Removing node from old parent\r\n        removeChildNode(oldParentNode, node);\r\n        // Changing parent of a node\r\n        if (typeof options.index === 'number') {\r\n            node.index = options.index;\r\n        }\r\n        else if (!options.maintainIndex) {\r\n            node.index = undefined;\r\n        }\r\n        insertChildNode(newParentNode, node);\r\n        // If moved node was an active child of the old parent, it needs to be cleaned out as well\r\n        this.unsetActiveChild(oldParentNode, node);\r\n        // If moved node which is (or it's subtree contains) currently focused node, then parent's active child needs to be adjusted\r\n        if (this.isSameOrParentForChild(node, this.currentFocusNode)) {\r\n            this.setActiveChildRecursive(newParentNode, node);\r\n        }\r\n    };\r\n    /**\r\n     * Registers a new node into the LRUD tree.\r\n     *\r\n     * Kept for backwards compatibility reasons.\r\n     *\r\n     * @param {string} nodeId - id of the node to register\r\n     * @param {object} [nodeConfig] - registered node parameters\r\n     */\r\n    Lrud.prototype.register = function (nodeId, nodeConfig) {\r\n        return this.registerNode(nodeId, nodeConfig);\r\n    };\r\n    /**\r\n     * Unregisters a node from the navigation tree.\r\n     *\r\n     * Kept for backwards compatibility reasons.\r\n     *\r\n     * @param {string|object} node - node or id of the node to unregister\r\n     * @param {object} [unregisterOptions]\r\n     */\r\n    Lrud.prototype.unregister = function (node, unregisterOptions) {\r\n        this.unregisterNode(node, unregisterOptions);\r\n    };\r\n    /**\r\n     * Unregisters a node from the navigation tree.\r\n     *\r\n     * @param {string|object} node - node or id of the node to unregister\r\n     * @param {object} [unregisterOptions]\r\n     * @param {boolean} [unregisterOptions.forceRefocus] if true, LRUD will attempt to re-focus on a new node if the currently focused\r\n     *                                                   node becomes unregistered due to the given node ID being unregistered\r\n     */\r\n    Lrud.prototype.unregisterNode = function (node, unregisterOptions) {\r\n        var _this = this;\r\n        if (unregisterOptions === void 0) { unregisterOptions = { forceRefocus: true }; }\r\n        node = typeof node === 'string' ? this.getNode(node) : node;\r\n        // if we're trying to unregister a node that doesn't exist, exit out\r\n        if (!node) {\r\n            return this;\r\n        }\r\n        if (node === this.rootNode) {\r\n            this.nodes = {};\r\n            this.rootNode = undefined;\r\n            this.currentFocusNode = undefined;\r\n            this.isIndexAlignMode = false;\r\n            this.emitter = mitt();\r\n            return this;\r\n        }\r\n        // get a copy of the node to pass to the blur event, and grab the parent to work with it\r\n        var parentNode = node.parent;\r\n        // ...if we're unregistering the activeChild of our parent (could be a leaf OR branch)\r\n        // we might need to recalculate the focus...\r\n        if (parentNode.activeChild && parentNode.activeChild === node) {\r\n            this.isIndexAlignMode = false;\r\n            this.unsetActiveChild(parentNode, node);\r\n        }\r\n        // delete the node itself (delete from the parent and re-set the parent later)\r\n        removeChildNode(parentNode, node);\r\n        // releasing memory references for node and all it's children all node's children\r\n        var currentFocusIsLost = false;\r\n        traverseNodeSubtree(node, function (traversedNode) {\r\n            delete _this.nodes[traversedNode.id];\r\n            // Unregistering overrides\r\n            _this.unregisterOverride(traversedNode);\r\n            // Unregistering overrides which pointed to unregistered node\r\n            for (var i = 0, overrideSources = traversedNode.overrideSources || []; i < overrideSources.length; i++) {\r\n                _this.unregisterOverride(overrideSources[i].node, overrideSources[i].direction);\r\n            }\r\n            // Unregistering currently focused node\r\n            if (traversedNode === _this.currentFocusNode) {\r\n                _this.currentFocusNode = undefined;\r\n                currentFocusIsLost = true;\r\n            }\r\n        });\r\n        // blur on the nodeClone\r\n        this.emitter.emit('blur', node);\r\n        if (node.onBlur) {\r\n            node.onBlur(node);\r\n        }\r\n        // check if the current focus node was removed, if so focus needs to be recalculated\r\n        if (currentFocusIsLost && unregisterOptions.forceRefocus) {\r\n            this.recalculateFocus(parentNode);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers a new override onto the LRUD instance.\r\n     *\r\n     * @param {string|object} source - node or id of the node for which override should be triggered\r\n     * @param {string|object} target - node or id of the node to which this overrides points\r\n     * @param {string} direction - traversal direction, for which this override should be triggered\r\n     * @param {object} [options]\r\n     * @param {boolean} [options.forceOverride] if true, existing override from source node in direction will be overwritten.\r\n     */\r\n    Lrud.prototype.registerOverride = function (source, target, direction, options) {\r\n        if (options === void 0) { options = {}; }\r\n        source = typeof source === 'string' ? this.getNode(source) : source;\r\n        if (!source) {\r\n            throw new Error('registering override: missing source node');\r\n        }\r\n        target = typeof target === 'string' ? this.getNode(target) : target;\r\n        if (!target) {\r\n            throw new Error('registering override: missing target node');\r\n        }\r\n        direction = toValidDirection(direction);\r\n        if (!direction) {\r\n            throw new Error('registering override: missing direction');\r\n        }\r\n        if (source.overrides && source.overrides[direction]) {\r\n            if (options.forceOverride) {\r\n                this.unregisterOverride(source, direction);\r\n            }\r\n            else {\r\n                throw new Error(\"registering override: override from \" + source.id + \" to \" + target.id + \" in direction \" + direction + \" already exist\");\r\n            }\r\n        }\r\n        source.overrides = source.overrides || {};\r\n        source.overrides[direction] = target;\r\n        target.overrideSources = target.overrideSources || [];\r\n        target.overrideSources.push({ direction: direction, node: source });\r\n        return this;\r\n    };\r\n    /**\r\n     * Unregisters an override from the LRUD instance.\r\n     *\r\n     * @param {string|object} source - node or id of the node for which override should be unregistered\r\n     * @param {string} [direction] - traversal direction, in which override should be unregistered\r\n     */\r\n    Lrud.prototype.unregisterOverride = function (source, direction) {\r\n        source = typeof source === 'string' ? this.getNode(source) : source;\r\n        if (!source || !source.overrides) {\r\n            return;\r\n        }\r\n        // if no direction provided, than removing all overrides\r\n        // if unknown direction provided, then aborting\r\n        if (direction) {\r\n            direction = toValidDirection(direction);\r\n            if (!direction) {\r\n                return;\r\n            }\r\n        }\r\n        var overridesToAreEmpty = true;\r\n        for (var _i = 0, _a = Object.keys(Directions); _i < _a.length; _i++) {\r\n            var directionKey = _a[_i];\r\n            var directionToRemove = Directions[directionKey];\r\n            if (direction && direction !== directionToRemove) {\r\n                overridesToAreEmpty = overridesToAreEmpty && !(source.overrides && source.overrides[directionToRemove]);\r\n                continue;\r\n            }\r\n            // removing reference to source node in target overridden in direction\r\n            var target = source.overrides[directionToRemove];\r\n            if (target && target.overrideSources) {\r\n                for (var i = 0; i < target.overrideSources.length; i++) {\r\n                    if (target.overrideSources[i].direction === directionToRemove && target.overrideSources[i].node === source) {\r\n                        if (target.overrideSources.length === 1) {\r\n                            target.overrideSources = undefined;\r\n                        }\r\n                        else {\r\n                            // The fastest way of removing element from array without maintaining the order:\r\n                            // put last element into removed one slot and make array shorter\r\n                            target.overrideSources[i] = target.overrideSources[target.overrideSources.length - 1];\r\n                            target.overrideSources.length = target.overrideSources.length - 1;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            // removing override\r\n            source.overrides[directionToRemove] = undefined;\r\n        }\r\n        // cleaning if no overrides defined\r\n        if (overridesToAreEmpty) {\r\n            source.overrides = undefined;\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns a node for an ID.\r\n     *\r\n     * @param {string} nodeId - id of the node to be returned\r\n     */\r\n    Lrud.prototype.getNode = function (nodeId) {\r\n        if (!nodeId) {\r\n            return undefined;\r\n        }\r\n        return this.nodes[nodeId];\r\n    };\r\n    /**\r\n     * Gets a node by ID and then unregisters it from the instance.\r\n     *\r\n     * @param {string} nodeId - id of the node to be picked\r\n     */\r\n    Lrud.prototype.pickNode = function (nodeId) {\r\n        var node = this.getNode(nodeId);\r\n        if (!node) {\r\n            return undefined;\r\n        }\r\n        this.unregisterNode(node);\r\n        return node;\r\n    };\r\n    /**\r\n     * Starting from a node, climb up the navigation tree until we find a node that can be\r\n     * actioned, based on the given direction. An actionable node is one whose orientation is valid\r\n     * for the given direction, has focusable children and whose activeChild isn't a leaf that is\r\n     * also its current activeChild.\r\n     *\r\n     * @param {object} node - node from which climbing up starts\r\n     * @param {string} direction - direction in which to traverse while climbing up\r\n     */\r\n    Lrud.prototype.climbUp = function (node, direction) {\r\n        while (node) {\r\n            // if we have a matching override at this point in the climb, return that target node\r\n            if (node.overrides && node.overrides[direction]) {\r\n                return node.overrides[direction];\r\n            }\r\n            // if we're on a currently focused node, climb up, definitely we are looking for some other node\r\n            if (node === this.currentFocusNode) {\r\n                // climb up\r\n                node = node.parent;\r\n                continue;\r\n            }\r\n            // we have children, but the orientation doesn't match, so try our parent\r\n            if (!isDirectionAndOrientationMatching(node.orientation, direction)) {\r\n                // climb up\r\n                node = node.parent;\r\n                continue;\r\n            }\r\n            // if we couldn't find any focusable candidate within children or we get currently\r\n            // activeChild, we have to look for other focusable candidate, climb up\r\n            if (!this.getNextFocusableChildInDirection(node, direction)) {\r\n                // climb up\r\n                node = node.parent;\r\n                continue;\r\n            }\r\n            return node;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Starting from the given node, dig down the navigation tree until we find a focusable\r\n     * leaf, and return it. dig \"direction\" priority:\r\n     * - index align mode\r\n     * - active child\r\n     * - first focusable child\r\n     *\r\n     * @param {object} node - node, from which digging down starts\r\n     * @param {string} [direction] - direction in which to traverse while digging down\r\n     */\r\n    Lrud.prototype.digDown = function (node, direction) {\r\n        if (direction === void 0) { direction = Directions.UNSPECIFIED; }\r\n        var _loop_1 = function () {\r\n            // If the node is focusable, then return it, but only when it doesn't contain focusable children.\r\n            // Otherwise, digging down to \"the deepest\" focusable node.\r\n            // Focusable \"leaf\" has a higher priority than focusable \"container\".\r\n            if (isNodeFocusable(node) && (node.isStopPropagate || !this_1.doesNodeHaveFocusableChildren(node))) {\r\n                return { value: node };\r\n            }\r\n            /*\r\n            if we're in a nested grid\r\n              if we're going VERTICAL DOWN\r\n                take the first child, and then match the index\r\n              if we're going VERTICAL UP\r\n                take the last child, and then match the index\r\n      \n            if we're in a nested grid\r\n              and we're going HORIZONTAL LEFT\r\n                take the matching index of the same depth, and then the last child\r\n              and we're going HORIZONTAL RIGHT\r\n                take the matching index of the same depth, and then the first child\r\n      \n            if its not a nested grid, take the matching index\r\n            */\r\n            if (this_1.isIndexAlignMode) {\r\n                var currentFocusedNode_1 = this_1.getCurrentFocusNode();\r\n                var currentFocusedIndexRange_1 = currentFocusedNode_1.indexRange;\r\n                var getIndex = function () {\r\n                    var useMeForIndexAlign = currentFocusedNode_1.parent.useMeForIndexAlign;\r\n                    if (useMeForIndexAlign) {\r\n                        return currentFocusedNode_1.parent.index;\r\n                    }\r\n                    if (currentFocusedIndexRange_1) {\r\n                        return currentFocusedIndexRange_1[0];\r\n                    }\r\n                    return currentFocusedNode_1.index;\r\n                };\r\n                var currentFocusedIndex = getIndex();\r\n                if (node.isIndexAlign) {\r\n                    // we're in a nested grid, so need to take into account orientation and direction of travel\r\n                    if (node.parent.orientation === Orientations.VERTICAL) {\r\n                        if (direction === Directions.UP) {\r\n                            // dig down\r\n                            node = findChildWithClosestIndex(this_1.getNodeLastChild(node), currentFocusedIndex, currentFocusedIndexRange_1);\r\n                            return \"continue\";\r\n                        }\r\n                        if (direction === Directions.DOWN) {\r\n                            // dig down\r\n                            node = findChildWithClosestIndex(this_1.getNodeFirstChild(node), currentFocusedIndex, currentFocusedIndexRange_1);\r\n                            return \"continue\";\r\n                        }\r\n                    }\r\n                    if (node.parent.orientation === Orientations.HORIZONTAL) {\r\n                        if (direction === Directions.LEFT) {\r\n                            // dig down\r\n                            node = this_1.getNodeLastChild(findChildWithClosestIndex(node, currentFocusedNode_1.parent.index));\r\n                            return \"continue\";\r\n                        }\r\n                        if (direction === Directions.RIGHT) {\r\n                            // dig down\r\n                            node = this_1.getNodeFirstChild(findChildWithClosestIndex(node, currentFocusedNode_1.parent.index));\r\n                            return \"continue\";\r\n                        }\r\n                    }\r\n                }\r\n                // we're not in a nested grid, so just look for matching index ranges or index\r\n                var matchingViaIndexRange = findChildWithMatchingIndexRange(node, currentFocusedIndex);\r\n                if (matchingViaIndexRange) {\r\n                    // dig down\r\n                    node = matchingViaIndexRange;\r\n                    return \"continue\";\r\n                }\r\n                else {\r\n                    // dig down\r\n                    node = findChildWithClosestIndex(node, currentFocusedIndex, currentFocusedIndexRange_1);\r\n                    return \"continue\";\r\n                }\r\n            }\r\n            // if possible, picking a branch that had focus in the past, one of its children was focused\r\n            if (node.activeChild) {\r\n                // dig down\r\n                node = node.activeChild;\r\n                return \"continue\";\r\n            }\r\n            // otherwise simply digging deeper, picking branch with first focusable candidate\r\n            node = this_1.getNextFocusableChildInDirection(node, Directions.UNSPECIFIED);\r\n        };\r\n        var this_1 = this;\r\n        while (node) {\r\n            var state_1 = _loop_1();\r\n            if (typeof state_1 === \"object\")\r\n                return state_1.value;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the semantic next focusable child for a given direction.\r\n     *\r\n     * If the direction is 'left' or 'up', return the semantic previous focusable child of the node.\r\n     * If the direction is 'right' or 'down'', return the semantic next focusable child of the node.\r\n     * If the direction is *, return the semantic next (or previous, if next not found) focusable child of the node.\r\n     *\r\n     * @param {object} node - node, for which next focusable child for a given direction is returned\r\n     * @param {string} direction - direction in which to traverse while searching for next focusable child\r\n     */\r\n    Lrud.prototype.getNextFocusableChildInDirection = function (node, direction) {\r\n        if (!node) {\r\n            return undefined;\r\n        }\r\n        var validOrientation = toValidOrientation(node.orientation);\r\n        var validDirection = toValidDirection(direction);\r\n        var nextChildInDirection;\r\n        var traverseForward = (validDirection === Directions.UNSPECIFIED) ||\r\n            (validOrientation === Orientations.HORIZONTAL && validDirection === Directions.RIGHT) ||\r\n            (validOrientation === Orientations.VERTICAL && validDirection === Directions.DOWN);\r\n        if (traverseForward) {\r\n            nextChildInDirection = this.getNextFocusableChild(node);\r\n        }\r\n        var traverseBackward = (validDirection === Directions.UNSPECIFIED) ||\r\n            (validOrientation === Orientations.HORIZONTAL && validDirection === Directions.LEFT) ||\r\n            (validOrientation === Orientations.VERTICAL && validDirection === Directions.UP);\r\n        if (!nextChildInDirection && traverseBackward) {\r\n            nextChildInDirection = this.getPrevFocusableChild(node);\r\n        }\r\n        return nextChildInDirection;\r\n    };\r\n    /**\r\n     * Gets the semantic \"next\" child for a node that might be focused or bypass focus to its children.\r\n     *\r\n     * @param {object} node - node, for which next focusable child is returned\r\n     */\r\n    Lrud.prototype.getNextFocusableChild = function (node) {\r\n        if (!node || !node.children) {\r\n            return undefined;\r\n        }\r\n        // there's no child that is (or was) focused, so we can quickly pick first focusable child\r\n        if (!node.activeChild) {\r\n            return this.getNodeFirstFocusableChild(node);\r\n        }\r\n        // starting right after child that is (or was) focused\r\n        for (var i = node.activeChild.index + 1; i < node.children.length; i++) {\r\n            if (this.isNodeFocusableCandidate(node.children[i])) {\r\n                return node.children[i];\r\n            }\r\n        }\r\n        // we haven't found a node so far, so looking from the beginning of list up to current active node if possible\r\n        if (node.isWrapping) {\r\n            for (var i = 0; i < node.activeChild.index; i++) {\r\n                if (this.isNodeFocusableCandidate(node.children[i])) {\r\n                    return node.children[i];\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the semantic \"previous\" child for a node that might be focused or bypass focus to its children.\r\n     *\r\n     * @param {object} node - node, for which previous focusable child is returned\r\n     */\r\n    Lrud.prototype.getPrevFocusableChild = function (node) {\r\n        if (!node || !node.children) {\r\n            return undefined;\r\n        }\r\n        // there's no child that is (or was) focused, so we can quickly pick last focusable child\r\n        if (!node.activeChild) {\r\n            return this.getNodeLastFocusableChild(node);\r\n        }\r\n        // starting right before child that is (or was) focused\r\n        for (var i = node.activeChild.index - 1; i >= 0; i--) {\r\n            if (this.isNodeFocusableCandidate(node.children[i])) {\r\n                return node.children[i];\r\n            }\r\n        }\r\n        // we haven't found a node so far, so looking from the end of list up to current active node if possible\r\n        if (node.isWrapping) {\r\n            for (var i = node.children.length - 1; i > node.activeChild.index; i--) {\r\n                if (this.isNodeFocusableCandidate(node.children[i])) {\r\n                    return node.children[i];\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the first child of a node, based on index.\r\n     *\r\n     * @param {object} node - node, for which first child is returned\r\n     */\r\n    Lrud.prototype.getNodeFirstChild = function (node) {\r\n        if (!node || !node.children) {\r\n            return undefined;\r\n        }\r\n        return node.children[0];\r\n    };\r\n    /**\r\n     * Gets the last child of a node, based on index.\r\n     *\r\n     * @param {object} node - node, for which last child is returned\r\n     */\r\n    Lrud.prototype.getNodeLastChild = function (node) {\r\n        if (!node || !node.children) {\r\n            return undefined;\r\n        }\r\n        return node.children[node.children.length - 1];\r\n    };\r\n    /**\r\n     * Gets the first focusable (or containing focusable nodes) child of a node, based on index.\r\n     *\r\n     * @param {object} node - node, for which first focusable child is returned\r\n     */\r\n    Lrud.prototype.getNodeFirstFocusableChild = function (node) {\r\n        if (!node || !node.children) {\r\n            return undefined;\r\n        }\r\n        for (var i = 0; i < node.children.length; i++) {\r\n            if (this.isNodeFocusableCandidate(node.children[i])) {\r\n                return node.children[i];\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the last focusable (or containing focusable nodes) child of a node, based on index.\r\n     *\r\n     * @param {object} node - node, for which last focusable child is returned\r\n     */\r\n    Lrud.prototype.getNodeLastFocusableChild = function (node) {\r\n        if (!node || !node.children) {\r\n            return undefined;\r\n        }\r\n        for (var i = node.children.length - 1; i >= 0; i--) {\r\n            if (this.isNodeFocusableCandidate(node.children[i])) {\r\n                return node.children[i];\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Given an event, handle any state changes that may arise from the direction pressed.\r\n     *\r\n     * State changes based on climbing up and digging down from the current focusedNode\r\n     *\r\n     * @param {object} event\r\n     * @param {number} [event.keyCode]\r\n     * @param {string} [event.direction]\r\n     * @param {object} [options]\r\n     * @param {boolean} [options.forceFocus] - if true and there's no currently focused node, LRUD will try to focus\r\n     *                                         first focusable node; default: false\r\n     */\r\n    Lrud.prototype.handleKeyEvent = function (event, options) {\r\n        if (options === void 0) { options = { forceFocus: false }; }\r\n        if (!event) {\r\n            return undefined;\r\n        }\r\n        var direction = (event.keyCode) ? getDirectionForKeyCode(event.keyCode) : toValidDirection(event.direction);\r\n        if (!direction) {\r\n            return undefined;\r\n        }\r\n        var currentFocusNode = this.getCurrentFocusNode();\r\n        // if all we're doing is processing an enter, just run the `onSelect` function of the current node...\r\n        if (direction === Directions.ENTER) {\r\n            if (currentFocusNode) {\r\n                this.emitter.emit('select', currentFocusNode);\r\n                if (currentFocusNode.onSelect) {\r\n                    currentFocusNode.onSelect(currentFocusNode);\r\n                }\r\n            }\r\n            return currentFocusNode;\r\n        }\r\n        var topNode;\r\n        var focusableNode;\r\n        if (!currentFocusNode && options.forceFocus) {\r\n            // No node is focused, focusing first focusable node\r\n            topNode = this.getRootNode();\r\n            focusableNode = this.getNextFocusableChildInDirection(topNode, Directions.UNSPECIFIED);\r\n        }\r\n        else {\r\n            // climb up from where we are...\r\n            topNode = this.climbUp(currentFocusNode, direction);\r\n            // ... if we cant find a top node, its an invalid move - just return\r\n            if (!topNode) {\r\n                return undefined;\r\n            }\r\n            // ...if we need to align indexes, turn the flag on now...\r\n            this.isIndexAlignMode = topNode.isIndexAlign === true;\r\n            // ...get the top's next child in the direction we're going...\r\n            var nextChild = this.getNextFocusableChildInDirection(topNode, direction);\r\n            // ...and depending on if we're able to find a child, dig down from the child or from the original top...\r\n            focusableNode = this.digDown(nextChild || topNode, direction);\r\n        }\r\n        if (!focusableNode) {\r\n            return undefined;\r\n        }\r\n        // ...give an opportunity for the move to be cancelled by the leaving node\r\n        if (currentFocusNode && currentFocusNode.shouldCancelLeave) {\r\n            if (currentFocusNode.shouldCancelLeave(currentFocusNode, focusableNode)) {\r\n                if (currentFocusNode.onLeaveCancelled) {\r\n                    currentFocusNode.onLeaveCancelled(currentFocusNode, focusableNode);\r\n                }\r\n                this.emitter.emit('cancelled', {\r\n                    leave: currentFocusNode,\r\n                    enter: focusableNode\r\n                });\r\n                return currentFocusNode;\r\n            }\r\n        }\r\n        // ...give an opportunity for the move to be cancelled by the entering node\r\n        if (focusableNode.shouldCancelEnter) {\r\n            if (focusableNode.shouldCancelEnter(currentFocusNode, focusableNode)) {\r\n                if (focusableNode.onEnterCancelled) {\r\n                    focusableNode.onEnterCancelled(currentFocusNode, focusableNode);\r\n                }\r\n                this.emitter.emit('cancelled', {\r\n                    leave: currentFocusNode,\r\n                    enter: focusableNode\r\n                });\r\n                return currentFocusNode;\r\n            }\r\n        }\r\n        // ...and then assign focus\r\n        this.assignFocus(focusableNode);\r\n        var offset = (direction === Directions.LEFT || direction === Directions.UP) ? -1 : 1;\r\n        // emit events and fire functions now that the move has completed\r\n        this.emitter.emit('move', {\r\n            leave: currentFocusNode,\r\n            enter: focusableNode,\r\n            direction: direction,\r\n            offset: offset\r\n        });\r\n        if (topNode.onMove) {\r\n            topNode.onMove({\r\n                node: topNode,\r\n                leave: currentFocusNode,\r\n                enter: focusableNode,\r\n                direction: direction,\r\n                offset: offset\r\n            });\r\n        }\r\n        if (currentFocusNode && currentFocusNode.onLeave) {\r\n            currentFocusNode.onLeave(currentFocusNode);\r\n        }\r\n        if (focusableNode.onEnter) {\r\n            focusableNode.onEnter(focusableNode);\r\n        }\r\n        return focusableNode;\r\n    };\r\n    /**\r\n     * Sets the activeChild of the parent node to the value of the child node.\r\n     *\r\n     * @param {string|object} parent - node or id of the node, which activeChild is about to be set\r\n     * @param {string|object} child - node or id of the node, that is about to be set as parent's activeChild\r\n     */\r\n    Lrud.prototype.setActiveChild = function (parent, child) {\r\n        parent = typeof parent === 'string' ? this.getNode(parent) : parent;\r\n        child = typeof child === 'string' ? this.getNode(child) : child;\r\n        if (!parent || !child) {\r\n            return;\r\n        }\r\n        if (child.parent.id !== parent.id) {\r\n            return;\r\n        }\r\n        // the parent already has an active child, and its NOT the same child that we're now setting\r\n        if (parent.activeChild && parent.activeChild.id !== child.id) {\r\n            var currentActiveChild = parent.activeChild;\r\n            parent.activeChild = child;\r\n            this.emitter.emit('inactive', currentActiveChild);\r\n            if (currentActiveChild.onInactive) {\r\n                currentActiveChild.onInactive(currentActiveChild);\r\n            }\r\n            this.emitter.emit('active', child);\r\n            if (child.onActive) {\r\n                child.onActive(child);\r\n            }\r\n            if (parent.onActiveChildChange) {\r\n                parent.onActiveChildChange({\r\n                    node: parent,\r\n                    leave: currentActiveChild,\r\n                    enter: child\r\n                });\r\n            }\r\n        }\r\n        else if (!parent.activeChild) {\r\n            parent.activeChild = child;\r\n            this.emitter.emit('active', child);\r\n            if (child.onActive) {\r\n                child.onActive(child);\r\n            }\r\n            if (parent.onActiveChildChange) {\r\n                parent.onActiveChildChange({\r\n                    node: parent,\r\n                    leave: null,\r\n                    enter: child\r\n                });\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Sets the activeChild of the parent node to the value of the child node.\r\n     *\r\n     * If the parent node has a parent itself, it digs up the tree and sets those activeChild values.\r\n     *\r\n     * @param {string|object} parent - node or id of the node, which activeChild is about to be set\r\n     * @param {string|object} child - node or id of the node, that is about to be set as parent's activeChild\r\n     */\r\n    Lrud.prototype.setActiveChildRecursive = function (parent, child) {\r\n        parent = typeof parent === 'string' ? this.getNode(parent) : parent;\r\n        child = typeof child === 'string' ? this.getNode(child) : child;\r\n        while (parent) {\r\n            this.setActiveChild(parent, child);\r\n            // if the parent has a parent, bubble up\r\n            child = parent;\r\n            parent = parent.parent;\r\n        }\r\n    };\r\n    /**\r\n     * Unsets the activeChild of the parent nodes branch ensuring that activeChild is on the unsetting child node path\r\n     * and not on the currentFocusNode's path, unless child node is a currentFocusNode.\r\n     *\r\n     * @param {string|object} parent - node or id of the node, which activeChild is about to be unset\r\n     * @param {string|object} activeChild - node or id of the node, that is about to be unset as parent's activeChild\r\n     */\r\n    Lrud.prototype.unsetActiveChild = function (parent, activeChild) {\r\n        parent = typeof parent === 'string' ? this.getNode(parent) : parent;\r\n        activeChild = typeof activeChild === 'string' ? this.getNode(activeChild) : activeChild;\r\n        if (!parent || !parent.activeChild) {\r\n            return;\r\n        }\r\n        if (!activeChild || parent.activeChild !== activeChild) {\r\n            return;\r\n        }\r\n        var isActiveChildAtCurrentFocusNodeBranch = this.isSameOrParentForChild(activeChild, this.currentFocusNode);\r\n        while (parent && parent.activeChild) {\r\n            var isParentAtActiveChildBranch = parent.activeChild === activeChild;\r\n            var isParentAtCurrentFocusedNodeBranch = this.isSameOrParentForChild(parent.activeChild, this.currentFocusNode);\r\n            if (isActiveChildAtCurrentFocusNodeBranch || (isParentAtActiveChildBranch && !isParentAtCurrentFocusedNodeBranch)) {\r\n                parent.activeChild = undefined;\r\n            }\r\n            activeChild = parent;\r\n            parent = parent.parent;\r\n        }\r\n    };\r\n    /**\r\n     * Sets the current focus of the instance to the given node or node ID.\r\n     *\r\n     * If the given node points to a non-focusable node, we dig down from\r\n     * the given node to find a node that can be focused on.\r\n     *\r\n     * Calls `onFocus` on the given node, if it exists, and emits a `focus` event,\r\n     * also calls `onBlur` on the node that WAS focused before this function was called.\r\n     *\r\n     * @param {string|object} node - node or id of the node to be focused\r\n     */\r\n    Lrud.prototype.assignFocus = function (node) {\r\n        node = typeof node === 'string' ? this.getNode(node) : node;\r\n        // Focus might be assigned to node that is not focusable itself, but\r\n        // contains focusable children, looking for such child\r\n        if (node && !isNodeFocusable(node)) {\r\n            node = this.digDown(node, Directions.UNSPECIFIED);\r\n        }\r\n        if (!node) {\r\n            throw new Error('trying to assign focus to a non focusable node');\r\n        }\r\n        if (this.currentFocusNode) {\r\n            this.emitter.emit('blur', this.currentFocusNode);\r\n            if (this.currentFocusNode.onBlur) {\r\n                this.currentFocusNode.onBlur(this.currentFocusNode);\r\n            }\r\n        }\r\n        this.currentFocusNode = node;\r\n        if (node.parent) {\r\n            this.setActiveChildRecursive(node.parent, node);\r\n        }\r\n        if (node.onFocus) {\r\n            node.onFocus(node);\r\n        }\r\n        this.emitter.emit('focus', node);\r\n    };\r\n    /**\r\n     * If the focus of the tree is out of sync, ie, the current focused node becomes unfocusable,\r\n     * this can be used to fall back to another focus.\r\n     *\r\n     * @param {object} node - node, based on which focus is recalculated\r\n     */\r\n    Lrud.prototype.recalculateFocus = function (node) {\r\n        var topNode = this.climbUp(node, Directions.UNSPECIFIED) || this.getRootNode();\r\n        var nextChild = this.getNextFocusableChildInDirection(topNode, Directions.UNSPECIFIED);\r\n        var focusableNode = this.digDown(nextChild || topNode, Directions.UNSPECIFIED);\r\n        if (focusableNode) {\r\n            this.assignFocus(focusableNode);\r\n        }\r\n        else {\r\n            this.currentFocusNode = undefined;\r\n        }\r\n    };\r\n    /**\r\n     * Given a tree, register all of its nodes into this instance.\r\n     *\r\n     * @param {object} subTreeRootNodeConfig\r\n     */\r\n    Lrud.prototype.registerTree = function (subTreeRootNodeConfig) {\r\n        var _this = this;\r\n        if (!subTreeRootNodeConfig) {\r\n            return;\r\n        }\r\n        traverseNodeSubtree(subTreeRootNodeConfig, function (traversedNodeConfig) {\r\n            _this.registerNode(traversedNodeConfig.id, traversedNodeConfig);\r\n            if (traversedNodeConfig.children) {\r\n                for (var i = 0; i < traversedNodeConfig.children.length; i++) {\r\n                    traversedNodeConfig.children[i].parent = traversedNodeConfig.id;\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Given a tree object, attempt to register that tree into the current lrud instance.\r\n     *\r\n     * If the given tree already exists as a branch in the instance tree, the new tree will replace that branch.\r\n     *\r\n     * If the new tree doesn't already exist as a branch in the instance tree, this function will register the new\r\n     * tree as a branch against the root node, as per standard registerNode() behaviour.\r\n     *\r\n     * @param {object} subTreeRootNodeConfig\r\n     * @param {object} [options]\r\n     * @param {boolean} [options.maintainIndex] - if true, and new tree is replacing an existing branch of the tree,\r\n     *                                            maintain the original branches relative index; default: true\r\n     */\r\n    Lrud.prototype.insertTree = function (subTreeRootNodeConfig, options) {\r\n        if (options === void 0) { options = { maintainIndex: true }; }\r\n        if (!subTreeRootNodeConfig) {\r\n            return;\r\n        }\r\n        var nodeToReplace = this.pickNode(subTreeRootNodeConfig.id);\r\n        if (!subTreeRootNodeConfig.parent && nodeToReplace && nodeToReplace.parent) {\r\n            subTreeRootNodeConfig.parent = nodeToReplace.parent.id;\r\n        }\r\n        if (options.maintainIndex && nodeToReplace && typeof nodeToReplace.index === 'number') {\r\n            subTreeRootNodeConfig.index = nodeToReplace.index;\r\n        }\r\n        this.registerTree(subTreeRootNodeConfig);\r\n    };\r\n    /**\r\n     * Checks is node contains children that might be focused (are a focusable candidates).\r\n     * It checks the whole node's children sub-tree, not only direct children.\r\n     *\r\n     * @param {object} node - node, which children are checked against being focusable candidates\r\n     */\r\n    Lrud.prototype.doesNodeHaveFocusableChildren = function (node) {\r\n        if (!node || !node.children) {\r\n            return false;\r\n        }\r\n        var nodeHaveFocusableChildren = false;\r\n        traverseNodeSubtree(node, function (traversedNode) {\r\n            // ignoring when subtree root, we are only interested in children focusability\r\n            if (traversedNode !== node) {\r\n                nodeHaveFocusableChildren = nodeHaveFocusableChildren || isNodeFocusable(traversedNode);\r\n            }\r\n            return nodeHaveFocusableChildren;\r\n        });\r\n        return nodeHaveFocusableChildren;\r\n    };\r\n    /**\r\n     * Checks if node is focusable or contains focusable children.\r\n     *\r\n     * @param {object} node - node to check against being focusable candidate\r\n     */\r\n    Lrud.prototype.isNodeFocusableCandidate = function (node) {\r\n        return isNodeFocusable(node) || this.doesNodeHaveFocusableChildren(node);\r\n    };\r\n    /**\r\n     * Checks if given parent node is a child's parent node or the node itself. If it's a parent it doesn't have\r\n     * to be a direct one, but has to be placed at a path to the root node.\r\n     *\r\n     * E.g.\r\n     *        root\r\n     *        / \\\r\n     *       A   B\r\n     *      /     \\\r\n     *     AA      BA\r\n     *    /  \\\r\n     *  AAA  AAB\r\n     *\r\n     *  Expect:\r\n     *    isSameOrParentForChild('A', 'A') -> true\r\n     *    isSameOrParentForChild('A', 'AA') -> true\r\n     *    isSameOrParentForChild('AA', 'A') -> false\r\n     *    isSameOrParentForChild('A', 'AAA') -> true\r\n     *    isSameOrParentForChild('AAA', 'AA') -> false\r\n     *    isSameOrParentForChild('A', 'BA') -> false\r\n     *    isSameOrParentForChild('BA', 'A') -> false\r\n     *    isSameOrParentForChild('AA', 'BA') -> false\r\n     *    isSameOrParentForChild('BA', 'AA') -> false\r\n     *\r\n     * @param {string|object} parent - parent or id of the examined parent\r\n     * @param {string|object} child - node id of the node which parents are queried\r\n     */\r\n    Lrud.prototype.isSameOrParentForChild = function (parent, child) {\r\n        parent = typeof parent === 'string' ? this.getNode(parent) : parent;\r\n        child = typeof child === 'string' ? this.getNode(child) : child;\r\n        if (!parent || !child) {\r\n            return false;\r\n        }\r\n        if (parent === child) {\r\n            return true;\r\n        }\r\n        while (child) {\r\n            if (child.parent === parent) {\r\n                return true;\r\n            }\r\n            child = child.parent;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Changes the ability of a node to be focused in place.\r\n     *\r\n     * @param {string|object} node - node or id of the node, which focusability property is about to be changed\r\n     * @param {boolean} isFocusable - focusability value to set\r\n     */\r\n    Lrud.prototype.setNodeFocusable = function (node, isFocusable) {\r\n        node = typeof node === 'string' ? this.getNode(node) : node;\r\n        if (!node) {\r\n            return;\r\n        }\r\n        var nodeIsFocusable = isNodeFocusable(node);\r\n        if (nodeIsFocusable === isFocusable) {\r\n            return;\r\n        }\r\n        node.isFocusable = isFocusable;\r\n        if (!isFocusable) {\r\n            if (this.currentFocusNode === node) {\r\n                this.recalculateFocus(node);\r\n            }\r\n            if (node.parent) {\r\n                this.unsetActiveChild(node.parent, node);\r\n            }\r\n        }\r\n    };\r\n    return Lrud;\r\n}());\n\nexport { Directions, Lrud, Orientations };\n","import { Direction, Lrud } from '@bam.tech/lrud';\n\nexport type OnDirectionHandledWithoutMovement = (direction: Direction) => void;\ntype OnDirectionHandledWithoutMovementRef = { current: OnDirectionHandledWithoutMovement };\n\ntype SpatialNavigatorParams = {\n  onDirectionHandledWithoutMovementRef: OnDirectionHandledWithoutMovementRef;\n};\n\nexport default class SpatialNavigator {\n  private lrud: Lrud;\n  private onDirectionHandledWithoutMovementRef: OnDirectionHandledWithoutMovementRef;\n\n  constructor({\n    onDirectionHandledWithoutMovementRef = { current: () => undefined },\n  }: SpatialNavigatorParams) {\n    this.lrud = new Lrud();\n    this.onDirectionHandledWithoutMovementRef = onDirectionHandledWithoutMovementRef;\n  }\n\n  private registerMap: { [key: string]: Array<Parameters<Lrud['registerNode']>> } = {};\n\n  public registerNode(...params: Parameters<Lrud['registerNode']>) {\n    try {\n      const parent = params[1]?.parent;\n      const id = params[0];\n\n      // If no parent is given, we are talking about a root node. We want to register it.\n      // If a parent is given, we need the node to exist. Otherwise, we'll pass and queue the node for later registration.\n      if (parent === undefined || this.lrud.getNode(parent)) {\n        this.lrud.registerNode(...params);\n\n        // After we successfully register a node, we need to check whether it needs to grab the focus or not.\n        this.handleQueuedFocus();\n\n        // OK, we successfully registered an element.\n        // Now, we check if some other elements were depending on us to be registered.\n        // ...and we do it recursively.\n        const potentialNodesToRegister = this.registerMap[id];\n        if (!potentialNodesToRegister || potentialNodesToRegister.length === 0) return;\n\n        potentialNodesToRegister.forEach((node) => {\n          this.registerNode(...node);\n        });\n        delete this.registerMap[id];\n      } else {\n        // If the parent is not registered yet, we queue the node for later registration.\n        if (!this.registerMap[parent]) {\n          this.registerMap[parent] = [];\n        }\n        this.registerMap[parent].push(params);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  public unregisterNode(...params: Parameters<Lrud['unregisterNode']>) {\n    this.lrud.unregisterNode(...params);\n  }\n\n  public async handleKeyDown(direction: Direction | null) {\n    if (!direction) return;\n    if (!this.hasRootNode) return;\n    if (!this.lrud.getRootNode()) return;\n\n    if (direction) {\n      const nodeBeforeMovement = this.lrud.getCurrentFocusNode();\n      this.lrud.handleKeyEvent({ direction }, { forceFocus: true });\n      const nodeAfterMovement = this.lrud.getCurrentFocusNode();\n\n      if (nodeBeforeMovement === nodeAfterMovement) {\n        this.onDirectionHandledWithoutMovementRef.current(direction);\n      }\n    }\n  }\n\n  public hasOneNodeFocused() {\n    return this.lrud.getCurrentFocusNode() !== undefined;\n  }\n\n  /**\n   * Sometimes we need to focus an element, but it is not registered yet.\n   * That's where we put this waiting element.\n   */\n  private focusQueue: string | null = null;\n\n  /**\n   * To handle the default focus, we want to queue the element to be focused.\n   * We queue it because it might not be registered yet when it asks for focus.\n   *\n   * We queue it only if there is no currently focused element already (or currently queued),\n   * because multiple elements might try to take the focus (DefaultFocus is a context, so all its children\n   * will try to grab it). We only want the first of these element to grab it.\n   */\n  public handleOrQueueDefaultFocus = (id: string) => {\n    if (this.getCurrentFocusNode()) return;\n    if (this.focusQueue) return;\n    if (this.lrud.getNode(id)) {\n      this.lrud.assignFocus(id);\n      return;\n    }\n    this.focusQueue = id;\n  };\n\n  /**\n   * Sometimes we want to queue focus an element, even if one is already focused.\n   * That happens with an imperative focus for example. I can force a focus to an element,\n   * even though another one is already focused.\n   *\n   * Still, I want to queue it, because the element might not be registered yet (example: in the case of virtualized lists)\n   */\n  public queueFocus = (id: string) => {\n    if (this.focusQueue) return;\n    this.focusQueue = id;\n  };\n\n  /**\n   * This will focus the currently queued element if it exists.\n   * Otherwise, it will do nothing.\n   *\n   * This function will eventually be called with the proper element\n   * when the element is finally registered.\n   */\n  private handleQueuedFocus = () => {\n    if (this.focusQueue && this.lrud.getNode(this.focusQueue)) {\n      try {\n        this.lrud.assignFocus(this.focusQueue);\n        this.focusQueue = null;\n      } catch (e) {\n        // pass\n      }\n    }\n  };\n\n  public grabFocus = (id: string) => {\n    return this.lrud.assignFocus(id);\n  };\n\n  public getCurrentFocusNode = () => {\n    return this.lrud.currentFocusNode;\n  };\n\n  private get hasRootNode(): boolean {\n    try {\n      this.lrud.getRootNode();\n      return true;\n    } catch (e) {\n      console.warn('[React Spatial Navigation] No registered node on this page.');\n      return false;\n    }\n  }\n}\n","import { SpatialNavigationNode, SpatialNavigationNodeDefaultProps } from './Node';\nimport { Platform, View, ViewStyle, ViewProps } from 'react-native';\nimport { forwardRef, useImperativeHandle, useMemo, useRef } from 'react';\nimport { SpatialNavigationNodeRef } from '../types/SpatialNavigationNodeRef';\nimport { useSpatialNavigationDeviceType } from '../context/DeviceContext';\nimport { useSpatialNavigatorFocusableAccessibilityProps } from '../hooks/useSpatialNavigatorFocusableAccessibilityProps';\n\ntype FocusableViewProps = {\n  style?: ViewStyle;\n  children:\n    | React.ReactElement\n    | ((props: { isFocused: boolean; isActive: boolean }) => React.ReactElement);\n  viewProps?: ViewProps & {\n    onMouseEnter?: () => void;\n  };\n};\n\ntype Props = SpatialNavigationNodeDefaultProps & FocusableViewProps;\n\nexport const SpatialNavigationFocusableView = forwardRef<SpatialNavigationNodeRef, Props>(\n  ({ children, style, viewProps, ...props }, ref) => {\n    const { deviceTypeRef } = useSpatialNavigationDeviceType();\n    const nodeRef = useRef<SpatialNavigationNodeRef>(null);\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        focus: () => nodeRef.current?.focus(),\n      }),\n      [nodeRef],\n    );\n\n    const webProps = Platform.select({\n      web: {\n        onMouseEnter: () => {\n          if (viewProps?.onMouseEnter) {\n            viewProps?.onMouseEnter();\n          }\n          if (deviceTypeRef.current === 'remotePointer') {\n            nodeRef.current?.focus();\n          }\n        },\n        onClick: () => {\n          props.onSelect?.();\n        },\n      },\n      default: {},\n    });\n\n    return (\n      <SpatialNavigationNode isFocusable {...props} ref={nodeRef}>\n        {({ isFocused, isActive }) => (\n          <InnerFocusableView\n            viewProps={viewProps}\n            webProps={webProps}\n            style={style}\n            isActive={isActive}\n            isFocused={isFocused}\n          >\n            {children}\n          </InnerFocusableView>\n        )}\n      </SpatialNavigationNode>\n    );\n  },\n);\nSpatialNavigationFocusableView.displayName = 'SpatialNavigationFocusableView';\n\ntype InnerFocusableViewProps = FocusableViewProps & {\n  webProps:\n    | {\n        onMouseEnter: () => void;\n        onClick: () => void;\n      }\n    | {\n        onMouseEnter?: undefined;\n        onClick?: undefined;\n      };\n  isActive: boolean;\n  isFocused: boolean;\n};\n\nconst InnerFocusableView = forwardRef<View, InnerFocusableViewProps>(\n  ({ viewProps, webProps, children, isActive, isFocused, style }, ref) => {\n    const accessibilityProps = useSpatialNavigatorFocusableAccessibilityProps();\n    const accessibilityState = useMemo(() => ({ selected: isFocused }), [isFocused]);\n\n    return (\n      <View\n        ref={ref}\n        style={style}\n        accessibilityState={accessibilityState}\n        {...accessibilityProps}\n        {...viewProps}\n        {...webProps}\n      >\n        {typeof children === 'function' ? children({ isFocused, isActive }) : children}\n      </View>\n    );\n  },\n);\nInnerFocusableView.displayName = 'InnerFocusableView';\n","import React, { forwardRef, useEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { View } from 'react-native';\nimport { useSpatialNavigatorDefaultFocus } from '../context/DefaultFocusContext';\nimport { ParentIdContext, useParentId } from '../context/ParentIdContext';\nimport { useSpatialNavigatorParentScroll } from '../context/ParentScrollContext';\nimport { useSpatialNavigator } from '../context/SpatialNavigatorContext';\nimport { useUniqueId } from '../hooks/useUniqueId';\nimport { NodeOrientation } from '../types/orientation';\nimport { NodeIndexRange } from '@bam.tech/lrud';\nimport { SpatialNavigationNodeRef } from '../types/SpatialNavigationNodeRef';\n\ntype FocusableProps = {\n  isFocusable: true;\n  children: (props: { isFocused: boolean; isActive: boolean }) => React.ReactElement;\n};\ntype NonFocusableProps = {\n  isFocusable?: false;\n  children: React.ReactElement | ((props: { isActive: boolean }) => React.ReactElement);\n};\ntype DefaultProps = {\n  onFocus?: () => void;\n  onBlur?: () => void;\n  onSelect?: () => void;\n  onActive?: () => void;\n  onInactive?: () => void;\n  orientation?: NodeOrientation;\n  /** Use this for nodes alignment.\n   * @see LRUD docs */\n  index?: number;\n  /** Use this for grid alignment.\n   * @see LRUD docs */\n  alignInGrid?: boolean;\n  indexRange?: NodeIndexRange;\n  /**\n   * This is an additional offset useful only for the scrollview. It adds up to the offsetFromStart of the scrollview.\n   */\n  additionalOffset?: number;\n};\ntype Props = DefaultProps & (FocusableProps | NonFocusableProps);\n\nexport type SpatialNavigationNodeDefaultProps = DefaultProps;\n\nconst useScrollToNodeIfNeeded = ({\n  childRef,\n  additionalOffset,\n}: {\n  childRef: React.MutableRefObject<View | null>;\n  additionalOffset?: number;\n}) => {\n  const { scrollToNodeIfNeeded } = useSpatialNavigatorParentScroll();\n\n  return () => scrollToNodeIfNeeded(childRef, additionalOffset);\n};\n\nconst useBindRefToChild = () => {\n  const childRef = useRef<View | null>(null);\n\n  const bindRefToChild = (child: React.ReactElement) => {\n    return React.cloneElement(child, {\n      ...child.props,\n      ref: (node: View) => {\n        // We need the reference for our scroll handling\n        childRef.current = node;\n\n        // @ts-expect-error @fixme This works at runtime but we couldn't find how to type it properly.\n        // Let's check if a ref was given (not by us)\n        const { ref } = child;\n        if (typeof ref === 'function') {\n          ref(node);\n        }\n\n        if (ref?.current !== undefined) {\n          ref.current = node;\n        }\n      },\n    });\n  };\n\n  return { bindRefToChild, childRef };\n};\n\nexport const SpatialNavigationNode = forwardRef<SpatialNavigationNodeRef, Props>(\n  (\n    {\n      onFocus,\n      onBlur,\n      onSelect,\n      onActive,\n      onInactive,\n      orientation = 'vertical',\n      index,\n      isFocusable = false,\n      alignInGrid = false,\n      indexRange,\n      children,\n      additionalOffset = 0,\n    }: Props,\n    ref,\n  ) => {\n    const spatialNavigator = useSpatialNavigator();\n    const parentId = useParentId();\n    const [isFocused, setIsFocused] = useState(false);\n    const [isActive, setIsActive] = useState(false);\n    // If parent changes, we have to re-register the Node + all children -> adding the parentId to the nodeId makes the children re-register.\n    const id = useUniqueId({ prefix: `${parentId}_node_` });\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        focus: () => spatialNavigator.grabFocus(id),\n      }),\n      [spatialNavigator, id],\n    );\n\n    const { childRef, bindRefToChild } = useBindRefToChild();\n\n    const scrollToNodeIfNeeded = useScrollToNodeIfNeeded({\n      childRef,\n      additionalOffset,\n    });\n\n    /*\n     * We don't re-register in LRUD on each render, because LRUD does not allow updating the nodes.\n     * Therefore, the SpatialNavigator Node callbacks are registered at 1st render but can change (ie. if props change) afterwards.\n     * Since we want the functions to always be up to date, we use a reference to them.\n     */\n\n    const currentOnSelect = useRef<() => void>();\n    currentOnSelect.current = onSelect;\n\n    const currentOnFocus = useRef<() => void>();\n    currentOnFocus.current = () => {\n      onFocus?.();\n      scrollToNodeIfNeeded();\n    };\n\n    const currentOnBlur = useRef<() => void>();\n    currentOnBlur.current = onBlur;\n\n    const currentOnActive = useRef<() => void>();\n    currentOnActive.current = onActive;\n\n    const currentOnInactive = useRef<() => void>();\n    currentOnInactive.current = onInactive;\n\n    const shouldHaveDefaultFocus = useSpatialNavigatorDefaultFocus();\n\n    useEffect(() => {\n      spatialNavigator.registerNode(id, {\n        parent: parentId,\n        isFocusable,\n        onBlur: () => {\n          currentOnBlur.current?.();\n          setIsFocused(false);\n        },\n        onFocus: () => {\n          currentOnFocus.current?.();\n          setIsFocused(true);\n        },\n        onSelect: () => currentOnSelect.current?.(),\n        orientation,\n        index,\n        isIndexAlign: alignInGrid,\n        indexRange,\n        onActive: () => {\n          currentOnActive.current?.();\n          setIsActive(true);\n        },\n        onInactive: () => {\n          currentOnInactive.current?.();\n          setIsActive(false);\n        },\n      });\n\n      return () => spatialNavigator.unregisterNode(id);\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- unfortunately, we can't have clean effects with lrud for now\n    }, [parentId]);\n\n    useEffect(() => {\n      if (shouldHaveDefaultFocus && isFocusable && !spatialNavigator.hasOneNodeFocused()) {\n        spatialNavigator.handleOrQueueDefaultFocus(id);\n      }\n    }, [id, isFocusable, shouldHaveDefaultFocus, spatialNavigator]);\n\n    return (\n      <ParentIdContext.Provider value={id}>\n        {typeof children === 'function'\n          ? bindRefToChild(children({ isFocused, isActive }))\n          : children}\n      </ParentIdContext.Provider>\n    );\n  },\n);\nSpatialNavigationNode.displayName = 'SpatialNavigationNode';\n","import { ReactNode, useEffect, useRef } from 'react';\nimport { ParentIdContext } from '../context/ParentIdContext';\nimport { SpatialNavigatorContext } from '../context/SpatialNavigatorContext';\nimport { useCreateSpatialNavigator } from '../hooks/useCreateSpatialNavigator';\nimport { useRemoteControl } from '../hooks/useRemoteControl';\nimport { OnDirectionHandledWithoutMovement } from '../SpatialNavigator';\nimport { LockSpatialNavigationContext, useIsLocked } from '../context/LockSpatialNavigationContext';\n\nconst ROOT_ID = 'root';\n\ntype Props = {\n  /**\n   * Determines if the spatial navigation is active.\n   * If false, the spatial navigation will be locked, and no nodes can be focused.\n   * This is useful to handle a multi page app: you can disable the non-focused pages' spatial navigation roots.\n   */\n  isActive?: boolean;\n  /**\n   * Called when you're reaching a border of the navigator.\n   * A use case for this would be the implementation of a side menu\n   * that's shared between pages. You can have a separate navigator\n   * for your side menu, which would be common across pages, and you'd\n   * make this menu active when you reach the left side of your page navigator.\n   */\n  onDirectionHandledWithoutMovement?: OnDirectionHandledWithoutMovement;\n  children: ReactNode;\n};\n\nexport const SpatialNavigationRoot = ({\n  isActive = true,\n  onDirectionHandledWithoutMovement = () => undefined,\n  children,\n}: Props) => {\n  // We can't follow the react philosophy here: we can't recreate a navigator if this function changes\n  // so we'll have to store its ref and update the ref if there is a new value to this function\n  const onDirectionHandledWithoutMovementRef = useRef<OnDirectionHandledWithoutMovement>(\n    () => undefined,\n  );\n  // Update the ref at every render\n  onDirectionHandledWithoutMovementRef.current = onDirectionHandledWithoutMovement;\n\n  const spatialNavigator = useCreateSpatialNavigator({\n    onDirectionHandledWithoutMovementRef,\n  });\n\n  const { isLocked, lockActions } = useIsLocked();\n\n  useRemoteControl({ spatialNavigator, isActive: isActive && !isLocked });\n\n  useEffect(() => {\n    spatialNavigator.registerNode(ROOT_ID, { orientation: 'vertical' });\n    return () => spatialNavigator.unregisterNode(ROOT_ID);\n  }, [spatialNavigator]);\n\n  return (\n    <SpatialNavigatorContext.Provider value={spatialNavigator}>\n      <LockSpatialNavigationContext.Provider value={lockActions}>\n        <ParentIdContext.Provider value={ROOT_ID}>{children}</ParentIdContext.Provider>\n      </LockSpatialNavigationContext.Provider>\n    </SpatialNavigatorContext.Provider>\n  );\n};\n","import React, { useCallback, RefObject, useRef, ReactElement, ReactNode, useMemo } from 'react';\nimport {\n  ScrollView,\n  View,\n  ViewStyle,\n  StyleSheet,\n  Platform,\n  NativeSyntheticEvent,\n  NativeScrollEvent,\n} from 'react-native';\nimport {\n  SpatialNavigatorParentScrollContext,\n  useSpatialNavigatorParentScroll,\n} from '../context/ParentScrollContext';\nimport { scrollToNewlyFocusedElement } from '../helpers/scrollToNewlyfocusedElement';\nimport { useSpatialNavigationDeviceType } from '../context/DeviceContext';\n\ntype Props = {\n  horizontal?: boolean;\n  /**\n   * Use this offset to prevent the element from sticking too closely to the edges of the screen during scrolling.\n   * This is a margin in pixels.\n   */\n  offsetFromStart?: number;\n  children: React.ReactNode;\n  style?: ViewStyle;\n  /** Arrow that will show up inside the arrowContainer */\n  descendingArrow?: ReactElement;\n  /** Arrow that will show up inside the arrowContainer */\n  ascendingArrow?: ReactElement;\n  /** Style props for the arrow container, basically the area hoverable that triggers a scroll  */\n  descendingArrowContainerStyle?: ViewStyle;\n  /** Style props for the arrow container, basically the area hoverable that triggers a scroll  */\n  ascendingArrowContainerStyle?: ViewStyle;\n  /** Number of pixels scrolled every 10ms - only when using web cursor pointer to scroll */\n  pointerScrollSpeed?: number;\n};\n\nconst useRemotePointerScrollviewScrollProps = ({\n  pointerScrollSpeed,\n  scrollY,\n  scrollViewRef,\n}: {\n  pointerScrollSpeed: number;\n  scrollY: React.MutableRefObject<number>;\n  scrollViewRef: React.MutableRefObject<ScrollView | null>;\n}) => {\n  const {\n    deviceType,\n    deviceTypeRef,\n    getScrollingIntervalId: getScrollingId,\n    setScrollingIntervalId: setScrollingId,\n  } = useSpatialNavigationDeviceType();\n\n  const onMouseEnterTop = useCallback(() => {\n    if (deviceTypeRef.current === 'remotePointer') {\n      let currentScrollPosition = scrollY.current;\n      const id = setInterval(() => {\n        currentScrollPosition -= pointerScrollSpeed;\n        scrollViewRef.current?.scrollTo({\n          y: currentScrollPosition,\n          animated: false,\n        });\n      }, 10);\n      setScrollingId(id);\n    }\n  }, [deviceTypeRef, pointerScrollSpeed, scrollY, scrollViewRef, setScrollingId]);\n\n  const onMouseEnterBottom = useCallback(() => {\n    if (deviceTypeRef.current === 'remotePointer') {\n      let currentScrollPosition = scrollY.current;\n      const id = setInterval(() => {\n        currentScrollPosition += pointerScrollSpeed;\n        scrollViewRef.current?.scrollTo({\n          y: currentScrollPosition,\n          animated: false,\n        });\n      }, 10);\n      setScrollingId(id);\n    }\n  }, [deviceTypeRef, pointerScrollSpeed, scrollY, scrollViewRef, setScrollingId]);\n\n  const onMouseLeave = useCallback(() => {\n    if (deviceTypeRef.current === 'remotePointer') {\n      const intervalId = getScrollingId();\n      if (intervalId) {\n        clearInterval(intervalId);\n        setScrollingId(null);\n      }\n    }\n  }, [deviceTypeRef, getScrollingId, setScrollingId]);\n\n  const ascendingArrowProps = useMemo(\n    () =>\n      Platform.select({\n        web: { onMouseEnter: onMouseEnterBottom, onMouseLeave: onMouseLeave },\n      }),\n    [onMouseEnterBottom, onMouseLeave],\n  );\n\n  const descendingArrowProps = useMemo(\n    () =>\n      Platform.select({\n        web: { onMouseEnter: onMouseEnterTop, onMouseLeave: onMouseLeave },\n      }),\n    [onMouseEnterTop, onMouseLeave],\n  );\n\n  return {\n    deviceType,\n    deviceTypeRef,\n    ascendingArrowProps,\n    descendingArrowProps,\n  };\n};\n\nconst getNodeRef = (node: ScrollView | null | undefined) => {\n  if (Platform.OS === 'web') {\n    return node?.getInnerViewNode();\n  }\n\n  return node;\n};\n\nexport const SpatialNavigationScrollView = ({\n  horizontal = false,\n  style,\n  offsetFromStart = 0,\n  children,\n  ascendingArrow,\n  ascendingArrowContainerStyle,\n  descendingArrow,\n  descendingArrowContainerStyle,\n  pointerScrollSpeed = 10,\n}: Props) => {\n  const { scrollToNodeIfNeeded: makeParentsScrollToNodeIfNeeded } =\n    useSpatialNavigatorParentScroll();\n  const scrollViewRef = useRef<ScrollView>(null);\n\n  const scrollY = useRef<number>(0);\n\n  const { ascendingArrowProps, descendingArrowProps, deviceType, deviceTypeRef } =\n    useRemotePointerScrollviewScrollProps({ pointerScrollSpeed, scrollY, scrollViewRef });\n\n  const scrollToNode = useCallback(\n    (newlyFocusedElementRef: RefObject<View>, additionalOffset = 0) => {\n      try {\n        if (deviceTypeRef.current === 'remoteKeys') {\n          newlyFocusedElementRef?.current?.measureLayout(\n            getNodeRef(scrollViewRef?.current),\n            (left, top) =>\n              scrollToNewlyFocusedElement({\n                newlyFocusedElementDistanceToLeftRelativeToLayout: left,\n                newlyFocusedElementDistanceToTopRelativeToLayout: top,\n                horizontal,\n                offsetFromStart: offsetFromStart + additionalOffset,\n                scrollViewRef,\n              }),\n            () => {},\n          );\n        }\n      } catch {\n        // A crash can happen when calling measureLayout when a page unmounts. No impact on focus detected in regular use cases.\n      }\n      makeParentsScrollToNodeIfNeeded(newlyFocusedElementRef, additionalOffset); // We need to propagate the scroll event for parents if we have nested ScrollViews/VirtualizedLists.\n    },\n    [makeParentsScrollToNodeIfNeeded, horizontal, offsetFromStart, deviceTypeRef],\n  );\n\n  const onScroll = useCallback(\n    (event: NativeSyntheticEvent<NativeScrollEvent>) => {\n      scrollY.current = event.nativeEvent.contentOffset.y;\n    },\n    [scrollY],\n  );\n\n  return (\n    <SpatialNavigatorParentScrollContext.Provider value={scrollToNode}>\n      <ScrollView\n        ref={scrollViewRef}\n        horizontal={horizontal}\n        style={style}\n        showsHorizontalScrollIndicator={false}\n        showsVerticalScrollIndicator={false}\n        scrollEnabled={false}\n        onScroll={onScroll}\n        scrollEventThrottle={16}\n      >\n        {children}\n      </ScrollView>\n      {deviceType === 'remotePointer' ? (\n        <PointerScrollArrows\n          descendingArrow={descendingArrow}\n          ascendingArrow={ascendingArrow}\n          descendingArrowContainerStyle={descendingArrowContainerStyle}\n          ascendingArrowContainerStyle={ascendingArrowContainerStyle}\n          ascendingArrowProps={ascendingArrowProps}\n          descendingArrowProps={descendingArrowProps}\n        />\n      ) : undefined}\n    </SpatialNavigatorParentScrollContext.Provider>\n  );\n};\n\nconst PointerScrollArrows = React.memo(\n  ({\n    ascendingArrow,\n    descendingArrowProps,\n    ascendingArrowContainerStyle,\n    descendingArrow,\n    ascendingArrowProps,\n    descendingArrowContainerStyle,\n  }: {\n    ascendingArrow?: ReactElement;\n    ascendingArrowProps?: {\n      onMouseEnter: () => void;\n      onMouseLeave: () => void;\n    };\n    ascendingArrowContainerStyle?: ViewStyle;\n    descendingArrow?: ReactNode;\n    descendingArrowProps?: {\n      onMouseEnter: () => void;\n      onMouseLeave: () => void;\n    };\n    descendingArrowContainerStyle?: ViewStyle;\n  }) => {\n    return (\n      <>\n        <View\n          style={[styles.arrowContainer, descendingArrowContainerStyle]}\n          {...descendingArrowProps}\n        >\n          {descendingArrow}\n        </View>\n        <View style={ascendingArrowContainerStyle} {...ascendingArrowProps}>\n          {ascendingArrow}\n        </View>\n      </>\n    );\n  },\n);\nPointerScrollArrows.displayName = 'PointerScrollArrows';\n\nconst styles = StyleSheet.create({\n  arrowContainer: {\n    position: 'absolute',\n  },\n});\n","import { StyleSheet, View, ViewStyle } from 'react-native';\nimport { SpatialNavigationNode } from './Node';\nimport { forwardRef } from 'react';\nimport { SpatialNavigationNodeRef } from '../types/SpatialNavigationNodeRef';\n\ntype Props = {\n  children: React.ReactNode;\n  style?: ViewStyle;\n  direction: 'horizontal' | 'vertical';\n  alignInGrid?: boolean;\n};\n\nexport const SpatialNavigationView = forwardRef<SpatialNavigationNodeRef, Props>(\n  ({ direction = 'horizontal', alignInGrid = false, children, style }: Props, ref) => {\n    return (\n      <SpatialNavigationNode orientation={direction} alignInGrid={alignInGrid} ref={ref}>\n        <View\n          style={[style, direction === 'horizontal' ? styles.viewHorizontal : styles.viewVertical]}\n        >\n          {children}\n        </View>\n      </SpatialNavigationNode>\n    );\n  },\n);\nSpatialNavigationView.displayName = 'SpatialNavigationView';\n\nconst styles = StyleSheet.create({\n  viewVertical: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n  viewHorizontal: {\n    display: 'flex',\n    flexDirection: 'row',\n  },\n});\n","import React, { ReactNode, useCallback, useEffect, useMemo } from 'react';\nimport { View, ViewStyle, StyleSheet } from 'react-native';\nimport range from 'lodash/range';\n\nimport { ItemWithIndex } from '../virtualizedList/VirtualizedList';\nimport { SpatialNavigationVirtualizedList } from '../virtualizedList/SpatialNavigationVirtualizedList';\nimport {\n  PointerScrollProps,\n  SpatialNavigationVirtualizedListWithScrollProps,\n} from '../virtualizedList/SpatialNavigationVirtualizedListWithScroll';\nimport { useSpatialNavigator } from '../../context/SpatialNavigatorContext';\nimport { ParentIdContext, useParentId } from '../../context/ParentIdContext';\nimport { typedMemo } from '../../helpers/TypedMemo';\nimport { convertToGrid } from './helpers/convertToGrid';\n\ntype SpatialNavigationVirtualizedGridProps<T extends ItemWithIndex> = Pick<\n  SpatialNavigationVirtualizedListWithScrollProps<T>,\n  | 'data'\n  | 'renderItem'\n  | 'onEndReached'\n  | 'style'\n  | 'nbMaxOfItems'\n  | 'scrollBehavior'\n  | 'scrollDuration'\n  | 'testID'\n> &\n  PointerScrollProps & {\n    itemHeight: number;\n    header?: JSX.Element;\n    headerSize?: number;\n    /** How many rows are RENDERED (virtualization size) */\n    numberOfRenderedRows: number;\n    /** How many rows are visible on screen (helps with knowing how to slice our data and to stop the scroll at the end of the list) */\n    numberOfRowsVisibleOnScreen: number;\n    /** Number of rows left to display before triggering onEndReached */\n    onEndReachedThresholdRowsNumber?: number;\n    /** Number of columns in the grid OR number of items per rows */\n    numberOfColumns: number;\n    /** Used to modify every row style */\n    rowContainerStyle?: ViewStyle;\n  };\n\nexport type GridRowType<T extends ItemWithIndex> = {\n  items: T[];\n  index: number;\n};\n\nconst useRegisterGridRowVirtualNodes = ({ numberOfColumns }: { numberOfColumns: number }) => {\n  const spatialNavigator = useSpatialNavigator();\n  const parentId = useParentId();\n\n  const getNthVirtualNodeID = useCallback((index: number) => `${parentId}_${index}`, [parentId]);\n\n  // This function must be idempotent so we don't register existing nodes again when grid data changes\n  const registerNthVirtualNode = useCallback(\n    (index: number) => {\n      return spatialNavigator.registerNode(getNthVirtualNodeID(index), {\n        parent: parentId,\n        orientation: 'horizontal',\n        isFocusable: false,\n        /** This prop enables index synchronization for navigation between rows.\n         * Thus you can navigate up and down inside columns, instead of going back to the first element of rows.\n         */\n        useMeForIndexAlign: true,\n      });\n    },\n    [spatialNavigator, parentId, getNthVirtualNodeID],\n  );\n\n  const unregisterNthVirtualNode = useCallback(\n    (index: number) => {\n      return spatialNavigator.unregisterNode(getNthVirtualNodeID(index));\n    },\n    [spatialNavigator, getNthVirtualNodeID],\n  );\n\n  useEffect(() => {\n    range(numberOfColumns).forEach((i) => registerNthVirtualNode(i));\n    return () => range(numberOfColumns).forEach((i) => unregisterNthVirtualNode(i));\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- unfortunately, we can't have clean effects with lrud for now\n  }, [parentId]);\n\n  return { getNthVirtualNodeID };\n};\n\nconst ItemWrapperWithVirtualParentContext = typedMemo(\n  <T extends ItemWithIndex>({\n    virtualParentID,\n    item,\n    renderItem,\n  }: {\n    virtualParentID: string;\n    item: T;\n    renderItem: (args: { item: T }) => JSX.Element;\n  }) => (\n    <ParentIdContext.Provider value={virtualParentID}>\n      {renderItem({ item })}\n    </ParentIdContext.Provider>\n  ),\n);\nItemWrapperWithVirtualParentContext.displayName = 'ItemWrapperWithVirtualParentContext';\n\nconst GridRow = <T extends ItemWithIndex>({\n  renderItem,\n  numberOfColumns,\n  row,\n  rowContainerStyle,\n}: {\n  renderItem: (args: { item: T }) => JSX.Element;\n  numberOfColumns: number;\n  row: GridRowType<T>;\n  rowContainerStyle?: ViewStyle;\n}) => {\n  const { getNthVirtualNodeID } = useRegisterGridRowVirtualNodes({ numberOfColumns });\n\n  return (\n    <HorizontalContainer style={rowContainerStyle}>\n      {row.items.map((item, index) => {\n        return (\n          /* This view is important to reset flex direction to vertical */\n          <View key={index}>\n            <ItemWrapperWithVirtualParentContext\n              virtualParentID={getNthVirtualNodeID(index)}\n              renderItem={renderItem}\n              item={item}\n            />\n          </View>\n        );\n      })}\n    </HorizontalContainer>\n  );\n};\n\n/**\n * Use this component to render spatially navigable grids of items.\n * Grids only support vertical orientation (vertically scrollable),\n * but you can navigate between elements in any direction.\n *\n * A grid is a series of horizontal rows rendering 'numberOfColumns' items.\n *\n * ```\n * \n *                   Screen                           \n *                                                    \n *   \n *   Row1                                           \n *                                                  \n *          \n *                                        \n *     A      B      C      D       E     \n *                                        \n *          \n *                                                  \n *   \n *                                                    \n *   \n *   Row2                                           \n *                                                  \n *          \n *                                        \n *      A     B      C      D      E      \n *                                        \n *          \n *                                                  \n *   \n *                                                    \n * \n *                           \n *     Row3                                          \n *   \n *           \n *                                      \n *        A     B      C      D      E     \n *                                      \n *           \n *   \n *                           \n * ```\n * The row framed in dotted lines corresponds to a virtualized component.\n * There is no virtualization inside rows.\n */\n\nexport const SpatialNavigationVirtualizedGrid = typedMemo(\n  <T extends ItemWithIndex>({\n    renderItem,\n    data,\n    numberOfColumns,\n    itemHeight,\n    header,\n    headerSize,\n    numberOfRenderedRows,\n    numberOfRowsVisibleOnScreen,\n    onEndReachedThresholdRowsNumber,\n    nbMaxOfItems,\n    rowContainerStyle,\n    ...props\n  }: SpatialNavigationVirtualizedGridProps<T>) => {\n    if (header && !headerSize) throw new Error('You must provide a headerSize when using a header');\n    if (headerSize && !header) throw new Error('You must provide a header when using a headerSize');\n    const hasHeader = !!header && !!headerSize;\n\n    const gridRows = useMemo(\n      () => convertToGrid(data, numberOfColumns, header),\n      [data, header, numberOfColumns],\n    );\n    const gridRowsWithHeaderIfProvided = useMemo(\n      () => (hasHeader ? [header, ...gridRows] : gridRows),\n      [hasHeader, header, gridRows],\n    );\n\n    const itemSizeAsAFunction = useCallback(\n      (item: GridRowType<T> | JSX.Element) => {\n        if (hasHeader && React.isValidElement(item)) {\n          return headerSize;\n        }\n        return itemHeight;\n      },\n      [hasHeader, headerSize, itemHeight],\n    );\n\n    const itemSize = hasHeader ? itemSizeAsAFunction : itemHeight;\n\n    const renderRow = useCallback(\n      ({ item: row }: { item: GridRowType<T> }) => (\n        <GridRow\n          renderItem={renderItem}\n          numberOfColumns={numberOfColumns}\n          row={row}\n          rowContainerStyle={rowContainerStyle}\n        />\n      ),\n      [renderItem, numberOfColumns, rowContainerStyle],\n    );\n    const renderHeaderThenRows = useCallback(\n      ({ item }: { item: GridRowType<T> | JSX.Element }) => {\n        if (React.isValidElement(item)) {\n          return item;\n        }\n        return renderRow({ item: item as GridRowType<T> });\n      },\n      [renderRow],\n    );\n\n    return (\n      <SpatialNavigationVirtualizedList\n        data={gridRowsWithHeaderIfProvided}\n        itemSize={itemSize}\n        numberOfRenderedItems={numberOfRenderedRows}\n        numberOfItemsVisibleOnScreen={numberOfRowsVisibleOnScreen}\n        onEndReachedThresholdItemsNumber={onEndReachedThresholdRowsNumber}\n        orientation=\"vertical\"\n        nbMaxOfItems={nbMaxOfItems ? Math.ceil(nbMaxOfItems / numberOfColumns) : undefined}\n        renderItem={renderHeaderThenRows}\n        isGrid\n        {...props}\n      />\n    );\n  },\n);\nSpatialNavigationVirtualizedGrid.displayName = 'SpatialNavigationVirtualizedGrid';\n\ntype HorizontalContainerProps = {\n  style?: ViewStyle;\n  children: ReactNode;\n};\n\nconst HorizontalContainer = ({ style, children }: HorizontalContainerProps) => {\n  return <View style={[style, styles.rowContainer]}>{children}</View>;\n};\n\nconst styles = StyleSheet.create({\n  rowContainer: { flexDirection: 'row' },\n});\n","import chunk from 'lodash/chunk';\nimport { GridRowType } from '../SpatialNavigationVirtualizedGrid';\nimport { ItemWithIndex } from '../../virtualizedList/VirtualizedList';\nimport { NodeOrientation } from '../../../types/orientation';\n\nexport const convertToGrid = <T extends ItemWithIndex>(\n  data: T[],\n  numberOfColumns: number,\n  header?: JSX.Element,\n): GridRowType<T>[] => {\n  const rows: T[][] = chunk(data, numberOfColumns);\n\n  return rows.map((items, index) => {\n    //We do this to have index taking into account the header\n    const computedIndex = header ? index + 1 : index;\n    return { items, index: computedIndex };\n  });\n};\n\nexport const invertOrientation = (orientation: NodeOrientation): NodeOrientation =>\n  orientation === 'vertical' ? 'horizontal' : 'vertical';\n","import { ForwardedRef, useMemo } from 'react';\nimport { SpatialNavigationNode } from '../Node';\nimport {\n  PointerScrollProps,\n  SpatialNavigationVirtualizedListWithScroll,\n  SpatialNavigationVirtualizedListWithScrollProps,\n} from './SpatialNavigationVirtualizedListWithScroll';\nimport { typedMemo } from '../../helpers/TypedMemo';\nimport { addIndex } from './helpers/addIndex';\nimport { ItemWithIndex } from './VirtualizedList';\nimport { typedForwardRef } from '../../helpers/TypedForwardRef';\nimport { SpatialNavigationVirtualizedListRef } from '../../types/SpatialNavigationVirtualizedListRef';\n\n/**\n * Use this component to render horizontally or vertically virtualized lists with spatial navigation\n * This component wraps the virtualized list inside a parent navigation node.\n * */\nexport const SpatialNavigationVirtualizedList = typedMemo(\n  typedForwardRef(\n    <T,>(\n      props: SpatialNavigationVirtualizedListWithScrollProps<T> & PointerScrollProps,\n      ref: ForwardedRef<SpatialNavigationVirtualizedListRef>,\n    ) => {\n      const indexedData = useMemo(() => addIndex(props.data), [props.data]);\n\n      return (\n        <SpatialNavigationNode\n          alignInGrid={props.isGrid ?? false}\n          orientation={props.orientation ?? 'horizontal'}\n        >\n          <SpatialNavigationVirtualizedListWithScroll<T & ItemWithIndex>\n            {...props}\n            data={indexedData}\n            ref={ref}\n          />\n        </SpatialNavigationNode>\n      );\n    },\n  ),\n);\nSpatialNavigationVirtualizedList.displayName = 'SpatialNavigationVirtualizedList';\n","import { ForwardedRef, useCallback, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport { VirtualizedListProps, ItemWithIndex } from './VirtualizedList';\n\nimport {\n  SpatialNavigationVirtualizedListWithVirtualNodes,\n  SpatialNavigationVirtualizedListWithVirtualNodesProps,\n  SpatialNavigationVirtualizedListWithVirtualNodesRef,\n} from './SpatialNavigationVirtualizedListWithVirtualNodes';\nimport {\n  ScrollToNodeCallback,\n  SpatialNavigatorParentScrollContext,\n  useSpatialNavigatorParentScroll,\n} from '../../context/ParentScrollContext';\nimport { typedMemo } from '../../helpers/TypedMemo';\nimport { useSpatialNavigationDeviceType } from '../../context/DeviceContext';\nimport { View, Platform, ViewStyle } from 'react-native';\nimport { useSpatialNavigator } from '../../context/SpatialNavigatorContext';\nimport React from 'react';\nimport { typedForwardRef } from '../../helpers/TypedForwardRef';\nimport { SpatialNavigationVirtualizedListRef } from '../../types/SpatialNavigationVirtualizedListRef';\n\nconst ItemWrapperWithScrollContext = typedMemo(\n  <T extends ItemWithIndex>({\n    setCurrentlyFocusedItemIndex,\n    item,\n    renderItem,\n  }: {\n    setCurrentlyFocusedItemIndex: (i: number) => void;\n    item: T;\n    renderItem: VirtualizedListProps<T>['renderItem'];\n  }) => {\n    const { scrollToNodeIfNeeded: makeParentsScrollToNodeIfNeeded } =\n      useSpatialNavigatorParentScroll();\n\n    const scrollToItem: ScrollToNodeCallback = useCallback(\n      (newlyFocusedElementRef, additionalOffset) => {\n        setCurrentlyFocusedItemIndex(item.index);\n        // We need to propagate the scroll event for parents if we have nested ScrollViews/VirtualizedLists.\n        makeParentsScrollToNodeIfNeeded(newlyFocusedElementRef, additionalOffset);\n      },\n      [makeParentsScrollToNodeIfNeeded, setCurrentlyFocusedItemIndex, item.index],\n    );\n\n    return (\n      <SpatialNavigatorParentScrollContext.Provider value={scrollToItem}>\n        {renderItem({ item })}\n      </SpatialNavigatorParentScrollContext.Provider>\n    );\n  },\n);\nItemWrapperWithScrollContext.displayName = 'ItemWrapperWithScrollContext';\n\nexport type SpatialNavigationVirtualizedListWithScrollProps<T> = Omit<\n  SpatialNavigationVirtualizedListWithVirtualNodesProps<T>,\n  'currentlyFocusedItemIndex'\n>;\n\nexport type PointerScrollProps = {\n  descendingArrow?: React.ReactElement;\n  descendingArrowContainerStyle?: ViewStyle;\n  ascendingArrow?: React.ReactElement;\n  ascendingArrowContainerStyle?: ViewStyle;\n  scrollInterval?: number;\n};\n\nconst useRemotePointerVirtualizedListScrollProps = ({\n  setCurrentlyFocusedItemIndex,\n  scrollInterval,\n  data,\n}: {\n  setCurrentlyFocusedItemIndex: React.Dispatch<React.SetStateAction<number>>;\n  scrollInterval: number;\n  data: ItemWithIndex[];\n}) => {\n  const {\n    deviceType,\n    deviceTypeRef,\n    getScrollingIntervalId: getScrollingId,\n    setScrollingIntervalId: setScrollingId,\n  } = useSpatialNavigationDeviceType();\n\n  const navigator = useSpatialNavigator();\n\n  const idRef = useRef<SpatialNavigationVirtualizedListWithVirtualNodesRef>(null);\n\n  const grabFocus = navigator.grabFocus;\n\n  const onMouseEnterDescending = useCallback(() => {\n    const callback = () => {\n      setCurrentlyFocusedItemIndex((index) => {\n        if (index > 0) {\n          if (idRef.current) grabFocus(idRef.current.getNthVirtualNodeID(index - 1));\n          return index - 1;\n        } else {\n          return index;\n        }\n      });\n    };\n\n    const id = setInterval(() => {\n      callback();\n    }, scrollInterval);\n    setScrollingId(id);\n  }, [grabFocus, scrollInterval, setCurrentlyFocusedItemIndex, setScrollingId]);\n\n  const onMouseLeave = useCallback(() => {\n    const intervalId = getScrollingId();\n    if (intervalId) {\n      clearInterval(intervalId);\n      setScrollingId(null);\n    }\n  }, [getScrollingId, setScrollingId]);\n\n  const onMouseEnterAscending = useCallback(() => {\n    const callback = () => {\n      setCurrentlyFocusedItemIndex((index) => {\n        if (index < data.length - 1) {\n          if (idRef.current) {\n            grabFocus(idRef.current.getNthVirtualNodeID(index + 1));\n          }\n          return index + 1;\n        } else {\n          return index;\n        }\n      });\n    };\n    const id = setInterval(() => {\n      callback();\n    }, scrollInterval);\n    setScrollingId(id);\n  }, [data.length, grabFocus, scrollInterval, setCurrentlyFocusedItemIndex, setScrollingId]);\n\n  const descendingArrowProps = useMemo(\n    () =>\n      Platform.select({\n        web: {\n          onMouseEnter: onMouseEnterDescending,\n          onMouseLeave: onMouseLeave,\n        },\n      }),\n    [onMouseEnterDescending, onMouseLeave],\n  );\n\n  const ascendingArrowProps = useMemo(\n    () =>\n      Platform.select({\n        web: {\n          onMouseEnter: onMouseEnterAscending,\n          onMouseLeave: onMouseLeave,\n        },\n      }),\n    [onMouseEnterAscending, onMouseLeave],\n  );\n\n  return {\n    descendingArrowProps,\n    ascendingArrowProps,\n    idRef,\n    deviceType,\n    deviceTypeRef,\n  };\n};\n\n/**\n * This component wraps every item of a virtualizedList in a scroll handling context.\n */\nexport const SpatialNavigationVirtualizedListWithScroll = typedMemo(\n  typedForwardRef(\n    <T extends ItemWithIndex>(\n      props: SpatialNavigationVirtualizedListWithScrollProps<T> & PointerScrollProps,\n      ref: ForwardedRef<SpatialNavigationVirtualizedListRef>,\n    ) => {\n      const {\n        data,\n        renderItem,\n        descendingArrow: descendingArrow,\n        ascendingArrow: ascendingArrow,\n        descendingArrowContainerStyle,\n        ascendingArrowContainerStyle,\n        scrollInterval = 100,\n      } = props;\n      const [currentlyFocusedItemIndex, setCurrentlyFocusedItemIndex] = useState(0);\n      const spatialNavigator = useSpatialNavigator();\n      const { deviceType, deviceTypeRef, descendingArrowProps, ascendingArrowProps, idRef } =\n        useRemotePointerVirtualizedListScrollProps({\n          setCurrentlyFocusedItemIndex,\n          scrollInterval,\n          data,\n        });\n\n      const setCurrentlyFocusedItemIndexCallback = useCallback(\n        (index: number) => {\n          deviceTypeRef.current === 'remoteKeys' ? setCurrentlyFocusedItemIndex(index) : null;\n        },\n        [deviceTypeRef],\n      );\n\n      useImperativeHandle(\n        ref,\n        () => ({\n          focus: async (index: number) => {\n            setCurrentlyFocusedItemIndex(index);\n            if (idRef.current) {\n              const newId = idRef.current.getNthVirtualNodeID(index);\n              spatialNavigator.queueFocus(newId);\n            }\n          },\n        }),\n        [idRef, spatialNavigator],\n      );\n\n      const renderWrappedItem: typeof props.renderItem = useCallback(\n        ({ item }) => (\n          <ItemWrapperWithScrollContext\n            setCurrentlyFocusedItemIndex={setCurrentlyFocusedItemIndexCallback}\n            renderItem={renderItem}\n            item={item}\n          />\n        ),\n        [setCurrentlyFocusedItemIndexCallback, renderItem],\n      );\n\n      return (\n        <>\n          <SpatialNavigationVirtualizedListWithVirtualNodes\n            {...props}\n            getNodeIdRef={idRef}\n            currentlyFocusedItemIndex={currentlyFocusedItemIndex}\n            renderItem={renderWrappedItem}\n          />\n          {deviceType === 'remotePointer' ? (\n            <PointerScrollArrows\n              descendingArrowContainerStyle={descendingArrowContainerStyle}\n              descendingArrowProps={descendingArrowProps}\n              descendingArrow={descendingArrow}\n              ascendingArrowContainerStyle={ascendingArrowContainerStyle}\n              ascendingArrowProps={ascendingArrowProps}\n              ascendingArrow={ascendingArrow}\n            />\n          ) : undefined}\n        </>\n      );\n    },\n  ),\n);\nSpatialNavigationVirtualizedListWithScroll.displayName =\n  'SpatialNavigationVirtualizedListWithScroll';\n\nconst PointerScrollArrows = React.memo(\n  ({\n    ascendingArrow,\n    ascendingArrowProps,\n    ascendingArrowContainerStyle,\n    descendingArrow,\n    descendingArrowProps,\n    descendingArrowContainerStyle,\n  }: PointerScrollProps & {\n    descendingArrowProps?: { onMouseEnter: () => void; onMouseLeave: () => void };\n    ascendingArrowProps?: { onMouseEnter: () => void; onMouseLeave: () => void };\n  }) => {\n    return (\n      <>\n        <View style={descendingArrowContainerStyle} {...descendingArrowProps}>\n          {descendingArrow}\n        </View>\n        <View style={ascendingArrowContainerStyle} {...ascendingArrowProps}>\n          {ascendingArrow}\n        </View>\n      </>\n    );\n  },\n);\nPointerScrollArrows.displayName = 'PointerScrollArrows';\n","import uniqueId from 'lodash.uniqueid';\nimport { useCallback, useEffect, useImperativeHandle, useRef } from 'react';\nimport { VirtualizedListProps, ItemWithIndex } from './VirtualizedList';\nimport { useSpatialNavigator } from '../../context/SpatialNavigatorContext';\nimport { ParentIdContext, useParentId } from '../../context/ParentIdContext';\nimport { updateVirtualNodeRegistration } from './helpers/updateVirtualNodeRegistration';\nimport { typedMemo } from '../../helpers/TypedMemo';\nimport { useCachedValues } from './hooks/useCachedValues';\nimport { NodeOrientation } from '../../types/orientation';\nimport { invertOrientation } from '../virtualizedGrid/helpers/convertToGrid';\nimport { VirtualizedListWithSize } from './VirtualizedListWithSize';\n\nconst useCreateVirtualParentsIds = (parentId: string) =>\n  useCachedValues(() => uniqueId(`${parentId}_virtual_`));\n\n/**\n * Hook which will :\n * - register the initial virtualNodes\n * - unregister the final virtualNodes\n * Do it each time the parentId is changing\n */\nconst useRegisterInitialAndUnregisterFinalVirtualNodes = <T,>({\n  allItems,\n  parentId,\n  registerNthVirtualNode,\n  unregisterNthVirtualNode,\n}: {\n  allItems: Array<T>;\n  parentId: string;\n  registerNthVirtualNode: (index: number) => void;\n  unregisterNthVirtualNode: (index: number) => void;\n}) => {\n  /** We don't unregister the nodes on each render because we want to update them instead (add new ones, move existing ones...).\n   * We register each item in allItems at 1st render, and unregister all the registered nodes on unmount.\n   * If data was added to allItems in the meantime (ex: onEndReached), the cleanup function needs to have \"access\" to this additional data in order to unregister the additional nodes.\n   * This means the cleanup function needs to have access to up-to-date data, so we use a reference to the list of data. */\n  const currentAllItems = useRef<Array<T>>(allItems);\n  currentAllItems.current = allItems;\n\n  useEffect(() => {\n    currentAllItems.current.forEach((_, n) => registerNthVirtualNode(n));\n\n    return () => currentAllItems.current.forEach((_, n) => unregisterNthVirtualNode(n));\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- unfortunately, we can't have clean effects with lrud for now\n  }, [parentId]);\n};\n\nconst useUpdateRegistration = <T,>({\n  allItems,\n  registerNthVirtualNode,\n}: {\n  allItems: Array<T>;\n  registerNthVirtualNode: (index: number) => void;\n}) => {\n  const previousAllItems = useRef<Array<T>>();\n\n  // useBeforeMountEffect done every time allItems is changing to change the way the allItems is register in the spatialNavigator\n  useEffect(() => {\n    const previousAllItemsList = previousAllItems.current;\n    const isFirstRender = previousAllItemsList === undefined;\n    if (!isFirstRender) {\n      updateVirtualNodeRegistration({\n        currentItems: allItems,\n        previousItems: previousAllItemsList,\n        addVirtualNode: registerNthVirtualNode,\n      });\n    }\n    previousAllItems.current = allItems;\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- unfortunately, we can't have clean effects with lrud for now\n  }, [allItems]);\n};\n\nconst useRegisterVirtualNodes = <T extends ItemWithIndex>({\n  allItems,\n  orientation,\n  isGrid,\n}: {\n  allItems: Array<T>;\n  orientation: NodeOrientation;\n  isGrid: boolean;\n}) => {\n  const spatialNavigator = useSpatialNavigator();\n  const parentId = useParentId();\n  const getNthVirtualNodeID = useCreateVirtualParentsIds(parentId);\n\n  // invert the orientation of children in grids so we can register rows in columns in rows, etc...\n  const nodeOrientation = isGrid ? invertOrientation(orientation) : 'vertical';\n\n  const registerNthVirtualNode = useCallback(\n    (index: number) => {\n      return spatialNavigator.registerNode(getNthVirtualNodeID(index), {\n        parent: parentId,\n        orientation: nodeOrientation,\n        isFocusable: false,\n      });\n    },\n    [getNthVirtualNodeID, parentId, spatialNavigator, nodeOrientation],\n  );\n\n  const unregisterNthVirtualNode = useCallback(\n    (index: number) => spatialNavigator.unregisterNode(getNthVirtualNodeID(index)),\n    [getNthVirtualNodeID, spatialNavigator],\n  );\n\n  useRegisterInitialAndUnregisterFinalVirtualNodes({\n    allItems,\n    parentId,\n    registerNthVirtualNode,\n    unregisterNthVirtualNode,\n  });\n\n  useUpdateRegistration({ allItems, registerNthVirtualNode });\n\n  return { getNthVirtualNodeID };\n};\n\nconst ItemWrapperWithVirtualParentContext = typedMemo(\n  <T extends ItemWithIndex>({\n    virtualParentID,\n    item,\n    renderItem,\n  }: {\n    virtualParentID: string;\n    item: T;\n    renderItem: VirtualizedListProps<T>['renderItem'];\n  }) => (\n    <ParentIdContext.Provider value={virtualParentID}>\n      {renderItem({ item })}\n    </ParentIdContext.Provider>\n  ),\n);\nItemWrapperWithVirtualParentContext.displayName = 'ItemWrapperWithVirtualParentContext';\n\nexport type SpatialNavigationVirtualizedListWithVirtualNodesProps<T> = Omit<\n  VirtualizedListProps<T>,\n  'listSizeInPx'\n> & {\n  isGrid?: boolean;\n};\n\nexport type SpatialNavigationVirtualizedListWithVirtualNodesRef = {\n  getNthVirtualNodeID: (index: number) => string;\n};\n\n/**\n * This component wraps every item of the VirtualizedList inside a Virtual Node.\n *\n * Virtual Nodes make the list more resilient to data changes.\n *\n * If the data changes, virtual nodes always wrap each elements for the spatial navigator to never lose track of the elements.\n * The strategy is to have as many virtual LRUD nodes as the amount data. For a N length array, we have N virtualized nodes. Even after pagination.\n * These virtual nodes are really helpful to never lose track of the navigation, especially if there is a refresh of the data and the array is shuffled.\n * ```\n *                       \n *                                       Screen                 \n *                                                              \n *                                                              \n *                \n *   1      2      3     4      5      6      7     8      9  \n *                          \n *   A     B    C   D    E    F    G   H     I  \n *                          \n *                \n *                                                              \n *                       \n * ```\n * Framed letters correspond to rendered components.\n */\nexport const SpatialNavigationVirtualizedListWithVirtualNodes = typedMemo(\n  <T extends ItemWithIndex>(\n    props: SpatialNavigationVirtualizedListWithVirtualNodesProps<T> & {\n      getNodeIdRef: React.Ref<SpatialNavigationVirtualizedListWithVirtualNodesRef>;\n    },\n  ) => {\n    const { getNthVirtualNodeID } = useRegisterVirtualNodes({\n      allItems: props.data,\n      orientation: props.orientation ?? 'horizontal',\n      isGrid: props.isGrid ?? false,\n    });\n\n    useImperativeHandle(\n      props.getNodeIdRef,\n      () => ({\n        getNthVirtualNodeID: getNthVirtualNodeID,\n      }),\n      [getNthVirtualNodeID],\n    );\n\n    const { renderItem } = props;\n    const renderWrappedItem: typeof props.renderItem = useCallback(\n      ({ item }) => (\n        <ItemWrapperWithVirtualParentContext\n          virtualParentID={getNthVirtualNodeID(item.index)}\n          renderItem={renderItem}\n          item={item}\n        />\n      ),\n      [getNthVirtualNodeID, renderItem],\n    );\n\n    return <VirtualizedListWithSize {...props} renderItem={renderWrappedItem} />;\n  },\n);\nSpatialNavigationVirtualizedListWithVirtualNodes.displayName =\n  'SpatialNavigationVirtualizedListWithVirtualNodes';\n","import { useCallback, useEffect, useMemo } from 'react';\nimport { Animated, StyleSheet, View, ViewStyle, Platform } from 'react-native';\nimport { getRange } from './helpers/getRange';\nimport {\n  useVirtualizedListAnimation,\n  useWebVirtualizedListAnimation,\n} from './hooks/useVirtualizedListAnimation';\nimport { NodeOrientation } from '../../types/orientation';\nimport { typedMemo } from '../../helpers/TypedMemo';\nimport { getLastLeftItemIndex, getLastRightItemIndex } from './helpers/getLastItemIndex';\nimport { getSizeInPxFromOneItemToAnother } from './helpers/getSizeInPxFromOneItemToAnother';\nimport { computeAllScrollOffsets } from './helpers/createScrollOffsetArray';\n\n/**\n * @TODO: VirtualizedList should be able to take any data as params.\n * We shouldn't restrict the use to a data that is indexed -> a mistake can be made on usage\n * if the data is not indexed properly for example.\n * The indexing should be done inside VirtualizedList directly & VirtualizedListProps\n * should accept any generic type T.\n */\nexport type ItemWithIndex = { index: number };\n\nexport type ScrollBehavior = 'stick-to-start' | 'stick-to-end' | 'jump-on-scroll';\nexport interface VirtualizedListProps<T> {\n  data: T[];\n  renderItem: (args: { item: T }) => JSX.Element;\n  /** If vertical the height of an item, otherwise the width */\n  itemSize: number | ((item: T) => number);\n  currentlyFocusedItemIndex: number;\n  /** How many items are RENDERED (virtualization size) */\n  numberOfRenderedItems: number;\n  /** How many items are visible on screen (helps with knowing how to slice our data and to stop the scroll at the end of the list) */\n  numberOfItemsVisibleOnScreen: number;\n  onEndReached?: () => void;\n  /** Number of items left to display before triggering onEndReached */\n  onEndReachedThresholdItemsNumber?: number;\n  style?: ViewStyle;\n  orientation?: NodeOrientation;\n  /**\n   * @deprecated\n   * Use a custom key instead of the recycling.\n   * */\n  keyExtractor?: (index: number) => string;\n  /** Total number of expected items for infinite scroll (helps aligning items) used for pagination */\n  nbMaxOfItems?: number;\n  /** Duration of a scrolling animation inside the VirtualizedList */\n  scrollDuration?: number;\n  /** The size of the list in its scrollable axis */\n  listSizeInPx: number;\n  scrollBehavior?: ScrollBehavior;\n  testID?: string;\n}\n\nconst useOnEndReached = ({\n  numberOfItems,\n  range,\n  currentlyFocusedItemIndex,\n  onEndReachedThresholdItemsNumber,\n  onEndReached,\n}: {\n  numberOfItems: number;\n  range: { start: number; end: number };\n  currentlyFocusedItemIndex: number;\n  onEndReachedThresholdItemsNumber: number;\n  onEndReached: (() => void) | undefined;\n}) => {\n  useEffect(() => {\n    if (numberOfItems === 0 || range.end === 0) {\n      return;\n    }\n\n    if (\n      currentlyFocusedItemIndex ===\n      Math.max(numberOfItems - 1 - onEndReachedThresholdItemsNumber, 0)\n    ) {\n      onEndReached?.();\n    }\n  }, [\n    onEndReached,\n    range.end,\n    currentlyFocusedItemIndex,\n    onEndReachedThresholdItemsNumber,\n    numberOfItems,\n  ]);\n};\n\nconst ItemContainerWithAnimatedStyle = typedMemo(\n  <T extends ItemWithIndex>({\n    item,\n    renderItem,\n    itemSize,\n    vertical,\n    data,\n  }: {\n    item: T;\n    renderItem: VirtualizedListProps<T>['renderItem'];\n    itemSize: number | ((item: T) => number);\n    vertical: boolean;\n    data: T[];\n  }) => {\n    const computeOffset = useCallback(\n      (item: T) =>\n        typeof itemSize === 'number'\n          ? item.index * itemSize\n          : data.slice(0, item.index).reduce((acc, item) => acc + itemSize(item), 0),\n      [data, itemSize],\n    );\n\n    const style = useMemo(\n      () =>\n        StyleSheet.flatten([\n          styles.item,\n          vertical\n            ? { transform: [{ translateY: computeOffset(item) }] }\n            : { transform: [{ translateX: computeOffset(item) }] },\n        ]),\n      [computeOffset, item, vertical],\n    );\n    return <View style={style}>{renderItem({ item })}</View>;\n  },\n);\nItemContainerWithAnimatedStyle.displayName = 'ItemContainerWithAnimatedStyle';\n\n/**\n * DO NOT use this component directly !\n * You should use the component SpatialNavigationVirtualizedList.tsx to render navigable lists of components.\n *\n * Why this has been made:\n *   - it gives us full control on the way we scroll (using CSS animations)\n *   - it is way more performant than a FlatList\n */\nexport const VirtualizedList = typedMemo(\n  <T extends ItemWithIndex>({\n    data,\n    renderItem,\n    itemSize,\n    currentlyFocusedItemIndex,\n    numberOfRenderedItems,\n    numberOfItemsVisibleOnScreen,\n    onEndReached,\n    onEndReachedThresholdItemsNumber = 3,\n    style,\n    orientation = 'horizontal',\n    nbMaxOfItems,\n    keyExtractor,\n    scrollDuration = 200,\n    listSizeInPx,\n    scrollBehavior = 'stick-to-start',\n    testID,\n  }: VirtualizedListProps<T>) => {\n    const range = getRange({\n      data,\n      currentlyFocusedItemIndex,\n      numberOfRenderedItems,\n      numberOfItemsVisibleOnScreen,\n    });\n\n    const vertical = orientation === 'vertical';\n\n    const totalVirtualizedListSize = useMemo(\n      () => getSizeInPxFromOneItemToAnother(data, itemSize, 0, data.length),\n      [data, itemSize],\n    );\n\n    const dataSliceToRender = data.slice(range.start, range.end + 1);\n\n    const maxPossibleLeftAlignedIndex = getLastLeftItemIndex<T>(data, itemSize, listSizeInPx);\n    const maxPossibleRightAlignedIndex = getLastRightItemIndex<T>(data, itemSize, listSizeInPx);\n\n    const allScrollOffsets = useMemo(\n      () =>\n        computeAllScrollOffsets({\n          itemSize: itemSize,\n          nbMaxOfItems: nbMaxOfItems ?? data.length,\n          numberOfItemsVisibleOnScreen: numberOfItemsVisibleOnScreen,\n          scrollBehavior: scrollBehavior,\n          data: data,\n          listSizeInPx: listSizeInPx,\n          maxPossibleLeftAlignedIndex: maxPossibleLeftAlignedIndex,\n          maxPossibleRightAlignedIndex: maxPossibleRightAlignedIndex,\n        }),\n      [\n        data,\n        itemSize,\n        listSizeInPx,\n        maxPossibleLeftAlignedIndex,\n        maxPossibleRightAlignedIndex,\n        nbMaxOfItems,\n        numberOfItemsVisibleOnScreen,\n        scrollBehavior,\n      ],\n    );\n\n    useOnEndReached({\n      numberOfItems: data.length,\n      range,\n      currentlyFocusedItemIndex,\n      onEndReachedThresholdItemsNumber,\n      onEndReached,\n    });\n\n    const animatedStyle =\n      Platform.OS === 'web'\n        ? useWebVirtualizedListAnimation({\n            currentlyFocusedItemIndex,\n            vertical,\n            scrollDuration,\n            scrollOffsetsArray: allScrollOffsets,\n          })\n        : useVirtualizedListAnimation({\n            currentlyFocusedItemIndex,\n            vertical,\n            scrollDuration,\n            scrollOffsetsArray: allScrollOffsets,\n          });\n\n    /*\n     * This is a performance trick.\n     * This custom key with a modulo is actually a \"recycled\" list implementation.\n     *\n     * Normally, if I scroll right, the first element needs to be unmounted and a new one needs to be mounted on the right side.\n     * But with recycling, the first element won't be unmounted : it is moved to the end and its props are updated.\n     * See https://medium.com/@moshe_31114/building-our-recycle-list-solution-in-react-17a21a9605a0  */\n    const recycledKeyExtractor = useCallback(\n      (index: number) => `recycled_item_${index % numberOfRenderedItems}`,\n      [numberOfRenderedItems],\n    );\n\n    const directionStyle = useMemo(\n      () => ({ flexDirection: vertical ? 'column' : 'row' } as const),\n      [vertical],\n    );\n\n    /**\n     * If the view has the size of the screen, then it is dropped in the component hierarchy when scrolled for more than the screen size (scroll right).\n     * To ensure that the view stays visible, we adat its size to the size of the virtualized list.\n     * ```\n     *                        Screen\n     *                  \n     *  View(container)                      \n     *         \n     *         \n     *                 \n     *         \n     *         \n     *                                       \n     *                  \n     *          \n     *   RowWidth = Screen Width + size of the item on left\n     * ```\n     */\n    const dimensionStyle = useMemo(\n      () =>\n        vertical\n          ? ({\n              height: totalVirtualizedListSize,\n            } as const)\n          : ({ width: totalVirtualizedListSize } as const),\n      [totalVirtualizedListSize, vertical],\n    );\n\n    return (\n      <Animated.View\n        style={[styles.container, animatedStyle, style, directionStyle, dimensionStyle]}\n        testID={testID}\n      >\n        <View>\n          {dataSliceToRender.map((item) => {\n            return (\n              <ItemContainerWithAnimatedStyle<T>\n                key={keyExtractor ? keyExtractor(item.index) : recycledKeyExtractor(item.index)}\n                renderItem={renderItem}\n                item={item}\n                itemSize={itemSize}\n                vertical={vertical}\n                data={data}\n              />\n            );\n          })}\n        </View>\n      </Animated.View>\n    );\n  },\n);\nVirtualizedList.displayName = 'VirtualizedList';\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  item: {\n    left: 0,\n    position: 'absolute',\n  },\n});\n","import { StyleSheet, View, Dimensions } from 'react-native';\nimport { typedMemo } from '../../helpers/TypedMemo';\nimport { ItemWithIndex, VirtualizedList, VirtualizedListProps } from './VirtualizedList';\nimport { useState } from 'react';\n\n/**\n * This component has for only purpose to give to the VirtualizedList its actual\n * width and height. It is used to avoid the VirtualizedList to render with a width\n * or height not defined (as it is used later for computing offsets for example).\n * The size is computed only once and then the VirtualizedList is rendered. This\n * doesn't support dynamic size changes.\n */\nexport const VirtualizedListWithSize = typedMemo(\n  <T extends ItemWithIndex>(props: Omit<VirtualizedListProps<T>, 'listSizeInPx'>) => {\n    const isVertical = props.orientation === 'vertical';\n    const [listSizeInPx, setListSizeInPx] = useState<number>(\n      isVertical ? Dimensions.get('window').height : Dimensions.get('window').width,\n    );\n    const [hasAlreadyRendered, setHasAlreadyRendered] = useState<boolean>(false);\n\n    return (\n      <View\n        style={style.container}\n        onLayout={(event) => {\n          if (!hasAlreadyRendered) {\n            const sizeKey = isVertical ? 'height' : 'width';\n            if (event.nativeEvent.layout[sizeKey] !== 0) {\n              setListSizeInPx(event.nativeEvent.layout[sizeKey]);\n              setHasAlreadyRendered(true);\n            }\n          }\n        }}\n        testID={props.testID ? props.testID + '-size-giver' : undefined}\n      >\n        {listSizeInPx ? <VirtualizedList {...props} listSizeInPx={listSizeInPx} /> : null}\n      </View>\n    );\n  },\n);\nVirtualizedListWithSize.displayName = 'VirtualizedListWithSize';\n\nconst style = StyleSheet.create({\n  container: {\n    width: '100%',\n    height: '100%',\n  },\n});\n","import { ItemWithIndex } from '../VirtualizedList';\n\nexport const addIndex = <T>(array: Array<T>): Array<T & ItemWithIndex> => {\n  return array.map((value, index) => ({ index, ...value }));\n};\n","import { ScrollBehavior } from '../VirtualizedList';\nimport { getSizeInPxFromOneItemToAnother } from './getSizeInPxFromOneItemToAnother';\n\nconst computeStickToStartTranslation = <T>({\n  currentlyFocusedItemIndex,\n  itemSizeInPx,\n  data,\n  maxPossibleLeftAlignedIndex,\n}: {\n  currentlyFocusedItemIndex: number;\n  itemSizeInPx: number | ((item: T) => number);\n  data: T[];\n  maxPossibleLeftAlignedIndex: number;\n}) => {\n  const scrollOffset =\n    currentlyFocusedItemIndex < maxPossibleLeftAlignedIndex\n      ? getSizeInPxFromOneItemToAnother(data, itemSizeInPx, 0, currentlyFocusedItemIndex)\n      : getSizeInPxFromOneItemToAnother(data, itemSizeInPx, 0, maxPossibleLeftAlignedIndex);\n  return -scrollOffset;\n};\n\nconst computeStickToEndTranslation = <T>({\n  currentlyFocusedItemIndex,\n  itemSizeInPx,\n  data,\n  listSizeInPx,\n  maxPossibleRightAlignedIndex,\n}: {\n  currentlyFocusedItemIndex: number;\n  itemSizeInPx: number | ((item: T) => number);\n  data: T[];\n  listSizeInPx: number;\n  maxPossibleRightAlignedIndex: number;\n}) => {\n  if (currentlyFocusedItemIndex <= maxPossibleRightAlignedIndex) return -0;\n\n  const currentlyFocusedItemSize =\n    typeof itemSizeInPx === 'function'\n      ? itemSizeInPx(data[currentlyFocusedItemIndex])\n      : itemSizeInPx;\n\n  const sizeOfListFromStartToCurrentlyFocusedItem = getSizeInPxFromOneItemToAnother(\n    data,\n    itemSizeInPx,\n    0,\n    currentlyFocusedItemIndex,\n  );\n\n  const scrollOffset =\n    sizeOfListFromStartToCurrentlyFocusedItem + currentlyFocusedItemSize - listSizeInPx;\n  return -scrollOffset;\n};\n\nconst computeJumpOnScrollTranslation = <T>({\n  currentlyFocusedItemIndex,\n  itemSizeInPx,\n  nbMaxOfItems,\n  numberOfItemsVisibleOnScreen,\n}: {\n  currentlyFocusedItemIndex: number;\n  itemSizeInPx: number | ((item: T) => number);\n  nbMaxOfItems: number;\n  numberOfItemsVisibleOnScreen: number;\n}) => {\n  if (typeof itemSizeInPx === 'function')\n    throw new Error('jump-on-scroll scroll behavior is not supported with dynamic item size');\n\n  const maxPossibleLeftAlignedIndex = Math.max(nbMaxOfItems - numberOfItemsVisibleOnScreen, 0);\n  const indexOfItemToFocus =\n    currentlyFocusedItemIndex - (currentlyFocusedItemIndex % numberOfItemsVisibleOnScreen);\n  const leftAlignedIndex = Math.min(indexOfItemToFocus, maxPossibleLeftAlignedIndex);\n  const scrollOffset = leftAlignedIndex * itemSizeInPx;\n  return -scrollOffset;\n};\n\nexport const computeTranslation = <T>({\n  currentlyFocusedItemIndex,\n  itemSizeInPx,\n  nbMaxOfItems,\n  numberOfItemsVisibleOnScreen,\n  scrollBehavior,\n  data,\n  listSizeInPx,\n  maxPossibleLeftAlignedIndex,\n  maxPossibleRightAlignedIndex,\n}: {\n  currentlyFocusedItemIndex: number;\n  itemSizeInPx: number | ((item: T) => number);\n  nbMaxOfItems: number;\n  numberOfItemsVisibleOnScreen: number;\n  scrollBehavior: ScrollBehavior;\n  data: T[];\n  listSizeInPx: number;\n  maxPossibleLeftAlignedIndex: number;\n  maxPossibleRightAlignedIndex: number;\n}) => {\n  switch (scrollBehavior) {\n    case 'stick-to-start':\n      return computeStickToStartTranslation({\n        currentlyFocusedItemIndex,\n        itemSizeInPx,\n        data,\n        maxPossibleLeftAlignedIndex,\n      });\n    case 'stick-to-end':\n      return computeStickToEndTranslation({\n        currentlyFocusedItemIndex,\n        itemSizeInPx,\n        data,\n        listSizeInPx,\n        maxPossibleRightAlignedIndex,\n      });\n    case 'jump-on-scroll':\n      return computeJumpOnScrollTranslation({\n        currentlyFocusedItemIndex,\n        itemSizeInPx,\n        nbMaxOfItems,\n        numberOfItemsVisibleOnScreen,\n      });\n    default:\n      throw new Error(`Invalid scroll behavior: ${scrollBehavior}`);\n  }\n};\n","import { ScrollBehavior } from '../VirtualizedList';\nimport { computeTranslation } from './computeTranslation';\n\n/**\n * This function precomputes all scroll offsets\n * It won't move until data moves or the itemSize changes\n */\nexport const computeAllScrollOffsets = <T>({\n  itemSize,\n  nbMaxOfItems,\n  numberOfItemsVisibleOnScreen,\n  scrollBehavior,\n  data,\n  listSizeInPx,\n  maxPossibleLeftAlignedIndex,\n  maxPossibleRightAlignedIndex,\n}: {\n  itemSize: number | ((item: T) => number);\n  nbMaxOfItems: number;\n  numberOfItemsVisibleOnScreen: number;\n  scrollBehavior: ScrollBehavior;\n  data: T[];\n  listSizeInPx: number;\n  maxPossibleLeftAlignedIndex: number;\n  maxPossibleRightAlignedIndex: number;\n}) => {\n  const scrollOffsets = data.map((_, index) =>\n    computeTranslation({\n      currentlyFocusedItemIndex: index,\n      itemSizeInPx: itemSize,\n      nbMaxOfItems: nbMaxOfItems ?? data.length,\n      numberOfItemsVisibleOnScreen: numberOfItemsVisibleOnScreen,\n      scrollBehavior: scrollBehavior,\n      data: data,\n      listSizeInPx: listSizeInPx,\n      maxPossibleLeftAlignedIndex: maxPossibleLeftAlignedIndex,\n      maxPossibleRightAlignedIndex: maxPossibleRightAlignedIndex,\n    }),\n  );\n\n  return scrollOffsets;\n};\n","/**\n * This function is used to compute the index of the last item that allows the end of the list to fully fit in the screen.\n * It is used when scrolling on stick-to-start mode.\n *\n * ```\n *      \n *                      Screen                 \n *                                             \n *                                             \n *           \n *    3     4      5      6      7   \n *           \n *   C   D    E    F    G  \n *           \n *           \n *                                             \n *      \n * ```\n *\n * In this case the last item that allows the end of the list to fully fit in the screen is item 4, so the\n * scroll in stick-to-start mode will be stopped after item 4, to keep\n * item 4 to 7 in the screen.\n *\n */\nexport const getLastLeftItemIndex = <T>(\n  data: T[],\n  itemSizeInPx: number | ((item: T) => number),\n  listSizeInPx: number,\n): number => {\n  if (typeof itemSizeInPx === 'function') {\n    let totalSize = 0;\n\n    for (let index = data.length - 1; index >= 0; index--) {\n      totalSize += itemSizeInPx(data[index]);\n\n      if (totalSize >= listSizeInPx) {\n        // If we exceed the list size, we return the index of the previous item (list is iterated backwards, so index + 1)\n        return index + 1;\n      }\n    }\n\n    return 0;\n  }\n  return data.length - Math.floor(listSizeInPx / itemSizeInPx);\n};\n\n/**\n *\n * This function is used to compute the index of the last item that fits in the screen when at the beginning of a list.\n * It is used when scrolling on stick-to-end mode to know when to start or stop scrolling\n *\n * ```\n *  \n *                  Screen                 \n *                                         \n *                                         \n *           \n *     1      2      3      4     5  \n *           \n *    A    B    C    D   E \n *           \n *           \n *                                         \n *  \n * ```\n *\n * In this case the last item that fits in the screen is item 4, so the\n * scroll in stick-to-end mode will be computed after item 4, to keep\n * item 5 (and the followings) on the right of the screen.\n *\n */\nexport const getLastRightItemIndex = <T>(\n  data: T[],\n  itemSizeInPx: number | ((item: T) => number),\n  listSizeInPx: number,\n): number => {\n  if (typeof itemSizeInPx === 'function') {\n    let totalSize = 0;\n\n    for (let index = 0; index < data.length; index++) {\n      totalSize += itemSizeInPx(data[index]);\n\n      if (totalSize >= listSizeInPx) {\n        // If we exceed the list size, we return the index of the previous item\n        return index - 1;\n      }\n    }\n\n    return data.length - 1;\n  }\n  // We substract 1 because index starts from 0\n  return Math.floor(listSizeInPx / itemSizeInPx) - 1;\n};\n","const positiveValueOrZero = (x: number): number => Math.max(x, 0);\n\n/**\n * ```\n *                                 numberOfItemsVisibleOnScreen\n *                          <>\n *                          \n *                             \n *                                                                              \n *         start focused                end         \n *                                                                              \n *                             \n *                          \n *               <>\n *                                     numberOfRenderedItems\n * ```\n **/\nconst getRangeWithoutFloatHandling = ({\n  data,\n  currentlyFocusedItemIndex,\n  numberOfRenderedItems = 8,\n  numberOfItemsVisibleOnScreen,\n}: {\n  data: Array<unknown>;\n  currentlyFocusedItemIndex: number;\n  numberOfRenderedItems?: number;\n  numberOfItemsVisibleOnScreen: number;\n}) => {\n  const numberOfItemsNotVisible = numberOfRenderedItems - numberOfItemsVisibleOnScreen;\n\n  /**\n   * NumberOfItemsNotVisible should be > 2 in order to be sure to have an element mounted on the left in order to go left\n   */\n  if (numberOfItemsNotVisible < 2) {\n    throw new Error(\n      'You have set a numberOfRenderedItems inferior to the numberOfItemsVisibleOnScreen + 2 in your SpatialNavigationVirtualizedList. You must change it.',\n    );\n  }\n\n  const halfNumberOfItemsNotVisible = numberOfItemsNotVisible / 2;\n  const lastDataIndex = data.length - 1;\n\n  const rawStartIndex = currentlyFocusedItemIndex - halfNumberOfItemsNotVisible;\n  const rawEndIndex =\n    currentlyFocusedItemIndex + halfNumberOfItemsNotVisible - 1 + numberOfItemsVisibleOnScreen;\n\n  /*\n   * if sum does not fit the window size, then we are in of these cases:\n   * - at the beginning of the data\n   * - at the end of the data\n   * - or we have too few data\n   */\n  if (rawStartIndex < 0) {\n    const finalEndIndex = numberOfRenderedItems - 1;\n    return { start: 0, end: positiveValueOrZero(Math.min(finalEndIndex, lastDataIndex)) };\n  }\n\n  if (rawEndIndex > data.length - 1) {\n    const finalStartIndex = lastDataIndex - numberOfRenderedItems + 1;\n    return { start: positiveValueOrZero(finalStartIndex), end: positiveValueOrZero(lastDataIndex) };\n  }\n\n  return { start: rawStartIndex, end: rawEndIndex };\n};\n\n/**\n * Computes an array slice for virtualization\n * Have a look at the tests to get examples!\n *\n * The tricky part is that we handle cases were the data is smaller than the window,\n * or when we are on the beginning of the screen...\n */\nexport const getRange = ({\n  data,\n  currentlyFocusedItemIndex,\n  numberOfRenderedItems = 8,\n  numberOfItemsVisibleOnScreen,\n}: {\n  data: Array<unknown>;\n  currentlyFocusedItemIndex: number;\n  numberOfRenderedItems?: number;\n  numberOfItemsVisibleOnScreen: number;\n}): { start: number; end: number } => {\n  if (numberOfRenderedItems <= 0) {\n    console.error(\n      '[VirtualizedList] Negative number of rendered items was given, no elements will be rendered',\n    );\n    return { start: 0, end: 0 };\n  }\n\n  const result = getRangeWithoutFloatHandling({\n    data,\n    currentlyFocusedItemIndex,\n    numberOfRenderedItems,\n    numberOfItemsVisibleOnScreen,\n  });\n\n  return { start: Math.ceil(result.start), end: Math.ceil(result.end) };\n};\n","/**\n * This function is used to compute the size in pixels of a range of items in a list.\n * If you want the size taken by items from index 0 to 5, you can call this function with\n * start = 0 and end = 5. The size is computed by summing the size of each item in the range.\n * @param data The list of items\n * @param itemSizeInPx The size of an item in pixels. It can be a number or a function that takes an item and returns a number.\n * @param start The start index of the range\n * @param end The end index of the range\n * @returns The size in pixels of the range of items\n **/\nexport const getSizeInPxFromOneItemToAnother = <T>(\n  data: T[],\n  itemSizeInPx: number | ((item: T) => number),\n  start: number,\n  end: number,\n): number => {\n  if (typeof itemSizeInPx === 'function') {\n    return data.slice(start, end).reduce((acc, item) => acc + itemSizeInPx(item), 0);\n  }\n  return data.slice(start, end).length * itemSizeInPx;\n};\n","const registerNewNode = <T>({\n  currentItems,\n  previousItems,\n  addVirtualNode,\n}: {\n  currentItems: Array<T>;\n  previousItems: Array<T>;\n  addVirtualNode: (index: number) => void;\n}) => {\n  currentItems.forEach((_, index) => {\n    // Currently this is the only way to compare both array and to know which elements to add\n    if (index > previousItems.length - 1) {\n      addVirtualNode(index);\n    }\n  });\n};\n\n/**\n * This function aims to compare 2 arrays of items : currentItems and previousItems and :\n * - addVirtualNode for every item from currentItems that weren't in previousItems\n * - removeVirtualNode for every item from previousItems that aren't there anymore in currentItems\n * - re-order all the items\n * For now it only does the Step 1.\n */\nexport const updateVirtualNodeRegistration = <T>({\n  currentItems,\n  previousItems,\n  addVirtualNode,\n}: {\n  currentItems: Array<T>;\n  previousItems: Array<T>;\n  addVirtualNode: (index: number) => void;\n}) => {\n  // Step 1 : addVirtualNode for every item from currentItems that weren't in previousItems\n  registerNewNode({ currentItems, previousItems, addVirtualNode });\n\n  // Step 2 : removeVirtualNode for every from previousItems that aren't there anymore in currentItems\n  // TODO\n\n  // Step 3 : re-order all the items\n  // TODO\n};\n","import { useCallback, useRef } from 'react';\n\n/**\n * Basically a useMemo for an array that creates elements on the go (not all at the beginning).\n *\n * The input & output might seem similar -> the difference is that\n * - input `nthElementConstructor` always returns a new instance of the Nth element\n * - output`getNthMemoizedElement` always return the same instance of the Nth element (memoized).\n *\n * @warning nthElementConstructor should never change\n *\n * @param nthElementConstructor a callback that returns what we want the Nth element to be.\n * @returns a callback to get the Nth memoized element.\n */\nexport const useCachedValues = <T>(nthElementConstructor: (n: number) => T): ((n: number) => T) => {\n  const memoizedElements = useRef<{ [n: number]: T }>({});\n\n  return useCallback((n: number) => {\n    if (memoizedElements.current[n]) return memoizedElements.current[n] as T;\n\n    const newElement = nthElementConstructor(n);\n    memoizedElements.current[n] = newElement;\n    return newElement;\n    /** We purposefully dont put `nthElementConstructor` as a dependency because, if it changed,\n     *  we would have to re-construct the whole cache. This use-case is not supported yet. */\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n};\n","import { useEffect, useRef } from 'react';\nimport { Animated, Easing } from 'react-native';\nimport { TypeVirtualizedListAnimation } from '../../../types/TypeVirtualizedListAnimation';\n\nexport const useVirtualizedListAnimation: TypeVirtualizedListAnimation = ({\n  currentlyFocusedItemIndex,\n  vertical = false,\n  scrollDuration,\n  scrollOffsetsArray,\n}) => {\n  const translation = useRef<Animated.Value>(new Animated.Value(0)).current;\n  const newTranslationValue = scrollOffsetsArray[currentlyFocusedItemIndex];\n\n  useEffect(() => {\n    Animated.timing(translation, {\n      toValue: newTranslationValue,\n      duration: scrollDuration,\n      useNativeDriver: true,\n      easing: Easing.out(Easing.sin),\n    }).start();\n  }, [translation, newTranslationValue, scrollDuration]);\n\n  return {\n    transform: [vertical ? { translateY: translation } : { translateX: translation }],\n  };\n};\n\nexport const useWebVirtualizedListAnimation: TypeVirtualizedListAnimation = ({\n  currentlyFocusedItemIndex,\n  vertical = false,\n  scrollDuration,\n  scrollOffsetsArray,\n}) => {\n  const animationDuration = `${scrollDuration}ms`;\n  const newTranslationValue = scrollOffsetsArray[currentlyFocusedItemIndex];\n\n  return {\n    transitionDuration: animationDuration,\n    transitionProperty: 'transform',\n    transitionTimingFunction: 'ease-out',\n    transform: [\n      vertical ? { translateY: newTranslationValue } : { translateX: newTranslationValue },\n    ],\n  };\n};\n","import { Direction } from '@bam.tech/lrud';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- can't know for sure what the subscriber will be...\ntype SubscriberType = any;\n\nexport interface RemoteControlConfiguration {\n  remoteControlSubscriber: (lrudCallback: (direction: Direction | null) => void) => SubscriberType;\n  remoteControlUnsubscriber: (subscriber: SubscriberType) => void;\n}\n\nexport let remoteControlSubscriber:\n  | RemoteControlConfiguration['remoteControlSubscriber']\n  | undefined = undefined;\nexport let remoteControlUnsubscriber:\n  | RemoteControlConfiguration['remoteControlUnsubscriber']\n  | undefined = undefined;\n\nexport const configureRemoteControl = (options: RemoteControlConfiguration) => {\n  remoteControlSubscriber = options.remoteControlSubscriber;\n  remoteControlUnsubscriber = options.remoteControlUnsubscriber;\n};\n","import React, { createContext, useContext } from 'react';\n\nconst SpatialNavigatorDefaultFocusContext = createContext<boolean>(false);\n\nexport const useSpatialNavigatorDefaultFocus = () => {\n  const spatialNavigatorDefaultFocus = useContext(SpatialNavigatorDefaultFocusContext);\n  return spatialNavigatorDefaultFocus;\n};\n\ntype Props = {\n  children: React.ReactNode;\n  enable?: boolean;\n};\n\nexport const DefaultFocus = ({ children, enable = true }: Props) => {\n  return (\n    <SpatialNavigatorDefaultFocusContext.Provider value={enable}>\n      {children}\n    </SpatialNavigatorDefaultFocusContext.Provider>\n  );\n};\n","import {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { Platform } from 'react-native';\n\ntype Device = 'remoteKeys' | 'remotePointer';\n\ninterface DeviceContextProps {\n  /** Use `deviceType` only if you need a render, otherwise use `deviceTypeRef` */\n  deviceType: Device;\n  /** Use `deviceTypeRef` for user events or if you don't need render, otherwise use `deviceType` */\n  deviceTypeRef: React.MutableRefObject<Device>;\n  setDeviceType: (deviceType: Device) => void;\n  getScrollingIntervalId: () => NodeJS.Timer | null;\n  setScrollingIntervalId: (scrollingId: NodeJS.Timer | null) => void;\n}\n\nexport const DeviceContext = createContext<DeviceContextProps>({\n  deviceType: 'remoteKeys',\n  deviceTypeRef: { current: 'remoteKeys' },\n  setDeviceType: () => {},\n  getScrollingIntervalId: () => null,\n  setScrollingIntervalId: () => {},\n});\n\ninterface DeviceProviderProps {\n  children: React.ReactNode;\n}\n\nexport const SpatialNavigationDeviceTypeProvider = ({ children }: DeviceProviderProps) => {\n  const [deviceType, setDeviceTypeWithoutRef] = useState<Device>('remoteKeys');\n\n  const deviceTypeRef = useRef<Device>(deviceType);\n  const scrollingId = useRef<NodeJS.Timer | null>(null);\n\n  const setDeviceType = useCallback((deviceType: Device) => {\n    deviceTypeRef.current = deviceType;\n    setDeviceTypeWithoutRef(deviceType);\n  }, []);\n\n  const setScrollingIntervalId = useCallback((id: NodeJS.Timer | null) => {\n    if (scrollingId.current) {\n      clearInterval(scrollingId.current);\n    }\n    scrollingId.current = id;\n  }, []);\n\n  const getScrollingIntervalId = useCallback(() => scrollingId.current, []);\n\n  useEffect(() => {\n    if (deviceType === 'remotePointer' || Platform.OS !== 'web') return;\n\n    const callback = () => {\n      setDeviceType('remotePointer');\n    };\n\n    window.addEventListener('mousemove', callback);\n    return () => window.removeEventListener('mousemove', callback);\n  }, [deviceType, setDeviceType]);\n\n  const value = useMemo(\n    () => ({\n      deviceType,\n      deviceTypeRef,\n      setDeviceType,\n      getScrollingIntervalId,\n      setScrollingIntervalId,\n    }),\n    [deviceType, setDeviceType, getScrollingIntervalId, setScrollingIntervalId],\n  );\n\n  return <DeviceContext.Provider value={value}>{children}</DeviceContext.Provider>;\n};\n\nexport const useSpatialNavigationDeviceType = (): DeviceContextProps => useContext(DeviceContext);\n","import { createContext, useContext, useMemo, useReducer } from 'react';\n\n/**\n * We store the number of times that we have been asked to lock the navigator\n * to avoid any race conditions\n *\n * It's more reliable than a simple boolean\n */\nconst lockReducer = (state: number, action: 'lock' | 'unlock'): number => {\n  switch (action) {\n    case 'lock':\n      return state + 1;\n    case 'unlock':\n      return state - 1;\n    default:\n      return state;\n  }\n};\n\nexport const useIsLocked = () => {\n  const [lockAmount, dispatch] = useReducer(lockReducer, 0);\n\n  const lockActions = useMemo(\n    () => ({\n      lock: () => dispatch('lock'),\n      unlock: () => dispatch('unlock'),\n    }),\n    [dispatch],\n  );\n\n  return {\n    isLocked: lockAmount !== 0,\n    lockActions,\n  };\n};\n\nexport const LockSpatialNavigationContext = createContext<{\n  lock: () => void;\n  unlock: () => void;\n}>({\n  lock: () => undefined,\n  unlock: () => undefined,\n});\n\nexport const useLockSpatialNavigation = () => {\n  const { lock, unlock } = useContext(LockSpatialNavigationContext);\n  return { lock, unlock };\n};\n","import { createContext, useContext } from 'react';\n\nexport const ParentIdContext = createContext<string | null>(null);\n\nexport const useParentId = () => {\n  const parentId = useContext(ParentIdContext);\n  if (!parentId) throw new Error('Node used without any Parent!');\n  return parentId;\n};\n","import { createContext, RefObject, useContext } from 'react';\nimport { View } from 'react-native';\n\nexport type ScrollToNodeCallback = (ref: RefObject<View>, additionalOffset?: number) => void;\nexport const SpatialNavigatorParentScrollContext = createContext<ScrollToNodeCallback>(() => {});\n\nexport const useSpatialNavigatorParentScroll = (): {\n  scrollToNodeIfNeeded: ScrollToNodeCallback;\n} => {\n  const scrollToNodeIfNeeded = useContext(SpatialNavigatorParentScrollContext);\n  return { scrollToNodeIfNeeded };\n};\n","import SpatialNavigator from '../SpatialNavigator';\nimport { createContext, useContext } from 'react';\n\nexport const SpatialNavigatorContext = createContext<SpatialNavigator | null>(null);\n\nexport const useSpatialNavigator = () => {\n  const spatialNavigator = useContext(SpatialNavigatorContext);\n  if (!spatialNavigator)\n    throw new Error(\n      'No registered spatial navigator on this page. Use the <SpatialNavigationRoot /> component.',\n    );\n  return spatialNavigator;\n};\n","import { ForwardedRef, ReactElement, RefAttributes, forwardRef } from 'react';\n\n/**\n * This works like React.forwardRef but for components with generics props.\n * @warning Don't use this if your component type isn't generic => `const Component = <T>() => {...}` and displayName is not supported yet\n */\nexport function typedForwardRef<T, P = unknown>(\n  render: (props: P, ref: ForwardedRef<T>) => ReactElement | null,\n): (props: P & RefAttributes<T>) => ReactElement | null {\n  return forwardRef(render) as (props: P & RefAttributes<T>) => ReactElement | null;\n}\n","import { ComponentType, memo, ComponentProps } from 'react';\n\ntype PropsComparator<C extends ComponentType> = (\n  prevProps: Readonly<ComponentProps<C>>,\n  nextProps: Readonly<ComponentProps<C>>,\n) => boolean;\n\n/**\n * This works like React.memo but for components with generics props.\n * See issue: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/37087\n * @warning Don't use this if your component type isn't generic => `const Component = <T>() => {...}`\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function typedMemo<C extends ComponentType<any>>(\n  Component: C,\n  propsAreEqual?: PropsComparator<C>,\n) {\n  return memo(Component, propsAreEqual) as unknown as C & { displayName?: string };\n}\n","import { RefObject } from 'react';\nimport { ScrollView } from 'react-native';\n\nexport type Props = {\n  newlyFocusedElementDistanceToLeftRelativeToLayout: number;\n  newlyFocusedElementDistanceToTopRelativeToLayout: number;\n  horizontal?: boolean;\n  offsetFromStart: number;\n  scrollViewRef: RefObject<ScrollView>;\n};\n\nexport const scrollToNewlyFocusedElement = ({\n  newlyFocusedElementDistanceToLeftRelativeToLayout,\n  newlyFocusedElementDistanceToTopRelativeToLayout,\n  horizontal,\n  offsetFromStart,\n  scrollViewRef,\n}: Props) => {\n  if (horizontal) {\n    scrollViewRef?.current?.scrollTo({\n      x: newlyFocusedElementDistanceToLeftRelativeToLayout - offsetFromStart,\n      // @todo make this a props of the component\n      animated: true,\n    });\n  } else {\n    scrollViewRef?.current?.scrollTo({\n      y: newlyFocusedElementDistanceToTopRelativeToLayout - offsetFromStart,\n      // @todo make this a props of the component\n      animated: true,\n    });\n  }\n};\n","import SpatialNavigator, { OnDirectionHandledWithoutMovement } from '../SpatialNavigator';\nimport { useMemo } from 'react';\n\ntype SpatialNavigatorHookParams = {\n  onDirectionHandledWithoutMovementRef: React.MutableRefObject<OnDirectionHandledWithoutMovement>;\n};\n\nexport const useCreateSpatialNavigator = ({\n  onDirectionHandledWithoutMovementRef,\n}: SpatialNavigatorHookParams) => {\n  const spatialNavigator = useMemo(\n    () =>\n      new SpatialNavigator({\n        onDirectionHandledWithoutMovementRef,\n      }),\n    // This dependency should be safe and won't recreate a navigator every time since it's a ref\n    [onDirectionHandledWithoutMovementRef],\n  );\n\n  return spatialNavigator;\n};\n","import SpatialNavigator from '../SpatialNavigator';\nimport { useEffect } from 'react';\nimport { remoteControlSubscriber, remoteControlUnsubscriber } from '../configureRemoteControl';\nimport { useSpatialNavigationDeviceType } from '../context/DeviceContext';\n\nexport const useRemoteControl = ({\n  spatialNavigator,\n  isActive,\n}: {\n  spatialNavigator: SpatialNavigator;\n  isActive: boolean;\n}) => {\n  const { setDeviceType, setScrollingIntervalId: setScrollingId } =\n    useSpatialNavigationDeviceType();\n  useEffect(() => {\n    if (!remoteControlSubscriber) {\n      console.warn(\n        '[React Spatial Navigation] You probably forgot to configure the remote control. Please call the configuration function.',\n      );\n\n      return;\n    }\n\n    if (!isActive) {\n      return () => undefined;\n    }\n\n    const listener = remoteControlSubscriber((direction) => {\n      setDeviceType('remoteKeys');\n      spatialNavigator.handleKeyDown(direction);\n      setScrollingId(null);\n    });\n    return () => {\n      if (!remoteControlUnsubscriber) {\n        console.warn(\n          '[React Spatial Navigation] You did not provide a remote control unsubscriber. Are you sure you called configuration correctly?',\n        );\n\n        return;\n      }\n      remoteControlUnsubscriber(listener);\n    };\n  }, [spatialNavigator, isActive, setDeviceType, setScrollingId]);\n};\n","import { useMemo } from 'react';\nimport { useParentId } from '../context/ParentIdContext';\nimport { useSpatialNavigator } from '../context/SpatialNavigatorContext';\n\nexport const useSpatialNavigatorFocusableAccessibilityProps = () => {\n  const spatialNavigator = useSpatialNavigator();\n  const id = useParentId();\n\n  const accessibilityProps = useMemo(\n    () => ({\n      accessible: true,\n      accessibilityRole: 'button' as const,\n      accessibilityActions: [{ name: 'activate' }] as const,\n      onAccessibilityAction: () => {\n        const currentNode = spatialNavigator.getCurrentFocusNode();\n\n        if (currentNode?.id === id) {\n          spatialNavigator.getCurrentFocusNode()?.onSelect?.(currentNode);\n        } else {\n          spatialNavigator.grabFocus(id);\n        }\n      },\n    }),\n    [id, spatialNavigator],\n  );\n\n  return accessibilityProps;\n};\n","import uniqueId from 'lodash.uniqueid';\nimport { useMemo } from 'react';\n\nexport const useUniqueId = ({ prefix }: { prefix?: string } = {}) =>\n  useMemo(() => uniqueId(prefix), [prefix]);\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to generate unique IDs. */\nvar idCounter = 0;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {string} [prefix=''] The value to prefix the ID with.\n * @returns {string} Returns the unique ID.\n * @example\n *\n * _.uniqueId('contact_');\n * // => 'contact_104'\n *\n * _.uniqueId();\n * // => '105'\n */\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\n\nmodule.exports = uniqueId;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\nmodule.exports = baseRange;\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n","var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n","var baseRange = require('./_baseRange'),\n    isIterateeCall = require('./_isIterateeCall'),\n    toFinite = require('./toFinite');\n\n/**\n * Creates a `_.range` or `_.rangeRight` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new range function.\n */\nfunction createRange(fromRight) {\n  return function(start, end, step) {\n    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n      end = step = undefined;\n    }\n    // Ensure the sign of `-0` is preserved.\n    start = toFinite(start);\n    if (end === undefined) {\n      end = start;\n      start = 0;\n    } else {\n      end = toFinite(end);\n    }\n    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n    return baseRange(start, end, step, fromRight);\n  };\n}\n\nmodule.exports = createRange;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n","var baseSlice = require('./_baseSlice'),\n    isIterateeCall = require('./_isIterateeCall'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * Creates an array of elements split into groups the length of `size`.\n * If `array` can't be split evenly, the final chunk will be the remaining\n * elements.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to process.\n * @param {number} [size=1] The length of each chunk\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the new array of chunks.\n * @example\n *\n * _.chunk(['a', 'b', 'c', 'd'], 2);\n * // => [['a', 'b'], ['c', 'd']]\n *\n * _.chunk(['a', 'b', 'c', 'd'], 3);\n * // => [['a', 'b', 'c'], ['d']]\n */\nfunction chunk(array, size, guard) {\n  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n    size = 1;\n  } else {\n    size = nativeMax(toInteger(size), 0);\n  }\n  var length = array == null ? 0 : array.length;\n  if (!length || size < 1) {\n    return [];\n  }\n  var index = 0,\n      resIndex = 0,\n      result = Array(nativeCeil(length / size));\n\n  while (index < length) {\n    result[resIndex++] = baseSlice(array, index, (index += size));\n  }\n  return result;\n}\n\nmodule.exports = chunk;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var createRange = require('./_createRange');\n\n/**\n * Creates an array of numbers (positive and/or negative) progressing from\n * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n * `start` is specified without an `end` or `step`. If `end` is not specified,\n * it's set to `start` with `start` then set to `0`.\n *\n * **Note:** JavaScript follows the IEEE-754 standard for resolving\n * floating-point values which can produce unexpected results.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @param {number} [step=1] The value to increment or decrement by.\n * @returns {Array} Returns the range of numbers.\n * @see _.inRange, _.rangeRight\n * @example\n *\n * _.range(4);\n * // => [0, 1, 2, 3]\n *\n * _.range(-4);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 5);\n * // => [1, 2, 3, 4]\n *\n * _.range(0, 20, 5);\n * // => [0, 5, 10, 15]\n *\n * _.range(0, -4, -1);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 4, 0);\n * // => [1, 1, 1]\n *\n * _.range(0);\n * // => []\n */\nvar range = createRange();\n\nmodule.exports = range;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var f=require(\"react\"),k=Symbol.for(\"react.element\"),l=Symbol.for(\"react.fragment\"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=\"\"+g);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__8156__;","module.exports = __WEBPACK_EXTERNAL_MODULE__9925__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { configureRemoteControl } from './spatial-navigation/configureRemoteControl';\nexport { Directions } from '@bam.tech/lrud';\nexport { SpatialNavigationNode } from './spatial-navigation/components/Node';\nexport { SpatialNavigationRoot } from './spatial-navigation/components/Root';\nexport { SpatialNavigationScrollView } from './spatial-navigation/components/ScrollView';\nexport { SpatialNavigationView } from './spatial-navigation/components/View';\nexport { DefaultFocus } from './spatial-navigation/context/DefaultFocusContext';\nexport { SpatialNavigationVirtualizedList } from './spatial-navigation/components/virtualizedList/SpatialNavigationVirtualizedList';\nexport { SpatialNavigationVirtualizedGrid } from './spatial-navigation/components/virtualizedGrid/SpatialNavigationVirtualizedGrid';\nexport { useSpatialNavigatorFocusableAccessibilityProps } from './spatial-navigation/hooks/useSpatialNavigatorFocusableAccessibilityProps';\nexport { useLockSpatialNavigation } from './spatial-navigation/context/LockSpatialNavigationContext';\nexport { SpatialNavigationNodeRef } from './spatial-navigation/types/SpatialNavigationNodeRef';\nexport { SpatialNavigationVirtualizedListRef } from './spatial-navigation/types/SpatialNavigationVirtualizedListRef';\nexport { SpatialNavigationFocusableView } from './spatial-navigation/components/FocusableView';\nexport { SpatialNavigationDeviceTypeProvider } from './spatial-navigation/context/DeviceContext';\n\nexport const SpatialNavigation = {\n  configureRemoteControl,\n};\n"],"names":["lrud_1","require","SpatialNavigator","constructor","onDirectionHandledWithoutMovementRef","current","undefined","registerMap","focusQueue","handleOrQueueDefaultFocus","id","getCurrentFocusNode","lrud","getNode","assignFocus","queueFocus","handleQueuedFocus","e","grabFocus","currentFocusNode","Lrud","registerNode","params","parent","_a","potentialNodesToRegister","length","forEach","node","push","console","error","unregisterNode","handleKeyDown","direction","hasRootNode","getRootNode","nodeBeforeMovement","handleKeyEvent","forceFocus","nodeAfterMovement","hasOneNodeFocused","warn","exports","default","Node_1","react_native_1","react_1","DeviceContext_1","useSpatialNavigatorFocusableAccessibilityProps_1","SpatialNavigationFocusableView","forwardRef","ref","children","style","viewProps","props","__rest","deviceTypeRef","useSpatialNavigationDeviceType","nodeRef","useRef","useImperativeHandle","focus","webProps","Platform","select","web","onMouseEnter","onClick","onSelect","call","jsx_runtime_1","jsx","SpatialNavigationNode","Object","assign","isFocusable","isFocused","isActive","InnerFocusableView","displayName","accessibilityProps","useSpatialNavigatorFocusableAccessibilityProps","accessibilityState","useMemo","selected","View","__importStar","DefaultFocusContext_1","ParentIdContext_1","ParentScrollContext_1","SpatialNavigatorContext_1","useUniqueId_1","useScrollToNodeIfNeeded","childRef","additionalOffset","scrollToNodeIfNeeded","useSpatialNavigatorParentScroll","useBindRefToChild","bindRefToChild","child","cloneElement","onFocus","onBlur","onActive","onInactive","orientation","index","alignInGrid","indexRange","spatialNavigator","useSpatialNavigator","parentId","useParentId","setIsFocused","useState","setIsActive","useUniqueId","prefix","currentOnSelect","currentOnFocus","currentOnBlur","currentOnActive","currentOnInactive","shouldHaveDefaultFocus","useSpatialNavigatorDefaultFocus","useEffect","isIndexAlign","ParentIdContext","Provider","value","useCreateSpatialNavigator_1","useRemoteControl_1","LockSpatialNavigationContext_1","ROOT_ID","SpatialNavigationRoot","onDirectionHandledWithoutMovement","useCreateSpatialNavigator","isLocked","lockActions","useIsLocked","useRemoteControl","SpatialNavigatorContext","LockSpatialNavigationContext","scrollToNewlyfocusedElement_1","useRemotePointerScrollviewScrollProps","pointerScrollSpeed","scrollY","scrollViewRef","deviceType","getScrollingIntervalId","getScrollingId","setScrollingIntervalId","setScrollingId","onMouseEnterTop","useCallback","currentScrollPosition","setInterval","scrollTo","y","animated","onMouseEnterBottom","onMouseLeave","intervalId","clearInterval","ascendingArrowProps","descendingArrowProps","getNodeRef","OS","getInnerViewNode","SpatialNavigationScrollView","horizontal","offsetFromStart","ascendingArrow","ascendingArrowContainerStyle","descendingArrow","descendingArrowContainerStyle","makeParentsScrollToNodeIfNeeded","scrollToNode","newlyFocusedElementRef","measureLayout","left","top","scrollToNewlyFocusedElement","newlyFocusedElementDistanceToLeftRelativeToLayout","newlyFocusedElementDistanceToTopRelativeToLayout","_b","onScroll","event","nativeEvent","contentOffset","jsxs","SpatialNavigatorParentScrollContext","ScrollView","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","scrollEnabled","scrollEventThrottle","PointerScrollArrows","memo","Fragment","styles","arrowContainer","StyleSheet","create","position","SpatialNavigationView","viewHorizontal","viewVertical","display","flexDirection","range_1","__importDefault","SpatialNavigationVirtualizedList_1","TypedMemo_1","convertToGrid_1","useRegisterGridRowVirtualNodes","numberOfColumns","getNthVirtualNodeID","registerNthVirtualNode","useMeForIndexAlign","unregisterNthVirtualNode","i","ItemWrapperWithVirtualParentContext","typedMemo","virtualParentID","item","renderItem","GridRow","row","rowContainerStyle","HorizontalContainer","items","map","SpatialNavigationVirtualizedGrid","data","itemHeight","header","headerSize","numberOfRenderedRows","numberOfRowsVisibleOnScreen","onEndReachedThresholdRowsNumber","nbMaxOfItems","Error","hasHeader","gridRows","convertToGrid","gridRowsWithHeaderIfProvided","itemSizeAsAFunction","isValidElement","itemSize","renderRow","renderHeaderThenRows","SpatialNavigationVirtualizedList","numberOfRenderedItems","numberOfItemsVisibleOnScreen","onEndReachedThresholdItemsNumber","Math","ceil","isGrid","rowContainer","chunk_1","rows","computedIndex","invertOrientation","SpatialNavigationVirtualizedListWithScroll_1","addIndex_1","TypedForwardRef_1","typedForwardRef","indexedData","addIndex","SpatialNavigationVirtualizedListWithScroll","SpatialNavigationVirtualizedListWithVirtualNodes_1","react_2","ItemWrapperWithScrollContext","setCurrentlyFocusedItemIndex","scrollToItem","useRemotePointerVirtualizedListScrollProps","scrollInterval","navigator","idRef","onMouseEnterDescending","callback","onMouseEnterAscending","currentlyFocusedItemIndex","setCurrentlyFocusedItemIndexCallback","__awaiter","newId","renderWrappedItem","SpatialNavigationVirtualizedListWithVirtualNodes","getNodeIdRef","lodash_uniqueid_1","updateVirtualNodeRegistration_1","useCachedValues_1","VirtualizedListWithSize_1","useCreateVirtualParentsIds","useCachedValues","useRegisterInitialAndUnregisterFinalVirtualNodes","allItems","currentAllItems","_","n","useUpdateRegistration","previousAllItems","previousAllItemsList","isFirstRender","updateVirtualNodeRegistration","currentItems","previousItems","addVirtualNode","useRegisterVirtualNodes","nodeOrientation","VirtualizedListWithSize","getRange_1","useVirtualizedListAnimation_1","getLastItemIndex_1","getSizeInPxFromOneItemToAnother_1","createScrollOffsetArray_1","useOnEndReached","numberOfItems","range","onEndReached","end","max","ItemContainerWithAnimatedStyle","vertical","computeOffset","slice","reduce","acc","flatten","transform","translateY","translateX","VirtualizedList","keyExtractor","scrollDuration","listSizeInPx","scrollBehavior","testID","getRange","totalVirtualizedListSize","getSizeInPxFromOneItemToAnother","dataSliceToRender","start","maxPossibleLeftAlignedIndex","getLastLeftItemIndex","maxPossibleRightAlignedIndex","getLastRightItemIndex","allScrollOffsets","computeAllScrollOffsets","animatedStyle","useWebVirtualizedListAnimation","scrollOffsetsArray","useVirtualizedListAnimation","recycledKeyExtractor","directionStyle","dimensionStyle","height","width","Animated","container","flex","VirtualizedList_1","isVertical","setListSizeInPx","Dimensions","get","hasAlreadyRendered","setHasAlreadyRendered","onLayout","sizeKey","layout","array","computeStickToStartTranslation","itemSizeInPx","scrollOffset","computeStickToEndTranslation","currentlyFocusedItemSize","sizeOfListFromStartToCurrentlyFocusedItem","computeJumpOnScrollTranslation","indexOfItemToFocus","leftAlignedIndex","min","computeTranslation","computeTranslation_1","scrollOffsets","totalSize","floor","positiveValueOrZero","x","getRangeWithoutFloatHandling","numberOfItemsNotVisible","halfNumberOfItemsNotVisible","lastDataIndex","rawStartIndex","rawEndIndex","finalEndIndex","finalStartIndex","result","registerNewNode","nthElementConstructor","memoizedElements","newElement","translation","Value","newTranslationValue","timing","toValue","duration","useNativeDriver","easing","Easing","out","sin","animationDuration","transitionDuration","transitionProperty","transitionTimingFunction","remoteControlSubscriber","remoteControlUnsubscriber","configureRemoteControl","options","SpatialNavigatorDefaultFocusContext","createContext","spatialNavigatorDefaultFocus","useContext","DefaultFocus","enable","DeviceContext","setDeviceType","SpatialNavigationDeviceTypeProvider","setDeviceTypeWithoutRef","scrollingId","window","addEventListener","removeEventListener","lockReducer","state","action","lockAmount","dispatch","useReducer","lock","unlock","useLockSpatialNavigation","render","Component","propsAreEqual","SpatialNavigator_1","configureRemoteControl_1","listener","accessible","accessibilityRole","accessibilityActions","name","onAccessibilityAction","currentNode","defineProperty","enumerable","Directions","Root_1","ScrollView_1","View_1","SpatialNavigationVirtualizedGrid_1","FocusableView_1","SpatialNavigation"],"sourceRoot":""}